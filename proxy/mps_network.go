/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"
	"strings"

	"github.com/be-io/mesh/client/golang/cause"
	"github.com/be-io/mesh/client/golang/macro"
	"github.com/be-io/mesh/client/golang/mpc"
	proxympx "github.com/be-io/mesh/client/golang/proxy"
	"github.com/be-io/mesh/client/golang/prsim"
	"github.com/be-io/mesh/client/golang/tool"
	"github.com/be-io/mesh/client/golang/types"
	_ "github.com/be-io/mesh/plugin/kms"
	prsimmps "github.com/be-io/mesh/plugin/prsim"
)

func init() {
	var service = &meshPRSINetworkMPS{mps: new(prsimmps.PRSINetwork)}
	var _ prsim.Network = service
	macro.Provide((*prsim.Network)(nil), service)

	var serviceGetEnviron = &meshPRSINetworkGetEnvironMPS{service: service}
	var _ mpc.Invoker = serviceGetEnviron
	var _ macro.Caller = serviceGetEnviron
	macro.Provide(mpc.IInvoker, serviceGetEnviron)
	macro.Provide(macro.ICaller, serviceGetEnviron)

	var serviceAccessible = &meshPRSINetworkAccessibleMPS{service: service}
	var _ mpc.Invoker = serviceAccessible
	var _ macro.Caller = serviceAccessible
	macro.Provide(mpc.IInvoker, serviceAccessible)
	macro.Provide(macro.ICaller, serviceAccessible)

	var serviceRefresh = &meshPRSINetworkRefreshMPS{service: service}
	var _ mpc.Invoker = serviceRefresh
	var _ macro.Caller = serviceRefresh
	macro.Provide(mpc.IInvoker, serviceRefresh)
	macro.Provide(macro.ICaller, serviceRefresh)

	var serviceGetRoute = &meshPRSINetworkGetRouteMPS{service: service}
	var _ mpc.Invoker = serviceGetRoute
	var _ macro.Caller = serviceGetRoute
	macro.Provide(mpc.IInvoker, serviceGetRoute)
	macro.Provide(macro.ICaller, serviceGetRoute)

	var serviceGetRoutes = &meshPRSINetworkGetRoutesMPS{service: service}
	var _ mpc.Invoker = serviceGetRoutes
	var _ macro.Caller = serviceGetRoutes
	macro.Provide(mpc.IInvoker, serviceGetRoutes)
	macro.Provide(macro.ICaller, serviceGetRoutes)

	var serviceGetDomains = &meshPRSINetworkGetDomainsMPS{service: service}
	var _ mpc.Invoker = serviceGetDomains
	var _ macro.Caller = serviceGetDomains
	macro.Provide(mpc.IInvoker, serviceGetDomains)
	macro.Provide(macro.ICaller, serviceGetDomains)

	var servicePutDomains = &meshPRSINetworkPutDomainsMPS{service: service}
	var _ mpc.Invoker = servicePutDomains
	var _ macro.Caller = servicePutDomains
	macro.Provide(mpc.IInvoker, servicePutDomains)
	macro.Provide(macro.ICaller, servicePutDomains)

	var serviceWeave = &meshPRSINetworkWeaveMPS{service: service}
	var _ mpc.Invoker = serviceWeave
	var _ macro.Caller = serviceWeave
	macro.Provide(mpc.IInvoker, serviceWeave)
	macro.Provide(macro.ICaller, serviceWeave)

	var serviceAck = &meshPRSINetworkAckMPS{service: service}
	var _ mpc.Invoker = serviceAck
	var _ macro.Caller = serviceAck
	macro.Provide(mpc.IInvoker, serviceAck)
	macro.Provide(macro.ICaller, serviceAck)

	var serviceDisable = &meshPRSINetworkDisableMPS{service: service}
	var _ mpc.Invoker = serviceDisable
	var _ macro.Caller = serviceDisable
	macro.Provide(mpc.IInvoker, serviceDisable)
	macro.Provide(macro.ICaller, serviceDisable)

	var serviceEnable = &meshPRSINetworkEnableMPS{service: service}
	var _ mpc.Invoker = serviceEnable
	var _ macro.Caller = serviceEnable
	macro.Provide(mpc.IInvoker, serviceEnable)
	macro.Provide(macro.ICaller, serviceEnable)

	var serviceIndex = &meshPRSINetworkIndexMPS{service: service}
	var _ mpc.Invoker = serviceIndex
	var _ macro.Caller = serviceIndex
	macro.Provide(mpc.IInvoker, serviceIndex)
	macro.Provide(macro.ICaller, serviceIndex)

	var serviceVersion = &meshPRSINetworkVersionMPS{service: service}
	var _ mpc.Invoker = serviceVersion
	var _ macro.Caller = serviceVersion
	macro.Provide(mpc.IInvoker, serviceVersion)
	macro.Provide(macro.ICaller, serviceVersion)

	var serviceInstx = &meshPRSINetworkInstxMPS{service: service}
	var _ mpc.Invoker = serviceInstx
	var _ macro.Caller = serviceInstx
	macro.Provide(mpc.IInvoker, serviceInstx)
	macro.Provide(macro.ICaller, serviceInstx)

	var serviceInstr = &meshPRSINetworkInstrMPS{service: service}
	var _ mpc.Invoker = serviceInstr
	var _ macro.Caller = serviceInstr
	macro.Provide(mpc.IInvoker, serviceInstr)
	macro.Provide(macro.ICaller, serviceInstr)

	var serviceAlly = &meshPRSINetworkAllyMPS{service: service}
	var _ mpc.Invoker = serviceAlly
	var _ macro.Caller = serviceAlly
	macro.Provide(mpc.IInvoker, serviceAlly)
	macro.Provide(macro.ICaller, serviceAlly)

	var serviceDisband = &meshPRSINetworkDisbandMPS{service: service}
	var _ mpc.Invoker = serviceDisband
	var _ macro.Caller = serviceDisband
	macro.Provide(mpc.IInvoker, serviceDisband)
	macro.Provide(macro.ICaller, serviceDisband)

	var serviceAssert = &meshPRSINetworkAssertMPS{service: service}
	var _ mpc.Invoker = serviceAssert
	var _ macro.Caller = serviceAssert
	macro.Provide(mpc.IInvoker, serviceAssert)
	macro.Provide(macro.ICaller, serviceAssert)

}

// meshPRSINetworkMPS is an implementation of prsim.PRSINetwork
type meshPRSINetworkMPS struct {
	mps *prsimmps.PRSINetwork
}

func (that *meshPRSINetworkMPS) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshSPI}
}

func (that *meshPRSINetworkMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: macro.MeshMPS}
}

// GetEnviron Get the meth network environment fixed information.
// @MPI("mesh.net.environ")
func (that *meshPRSINetworkMPS) GetEnviron(ctx context.Context) (*types.Environ, error) {
	return that.mps.GetEnviron(ctx)
}

// Accessible Check the mesh network is accessible.
// @MPI("mesh.net.accessible")
func (that *meshPRSINetworkMPS) Accessible(ctx context.Context, route *types.Route) (bool, error) {
	return that.mps.Accessible(ctx, route)
}

// Refresh the routes to mesh network.
// @MPI("mesh.net.refresh")
func (that *meshPRSINetworkMPS) Refresh(ctx context.Context, routes []*types.Route) error {
	return that.mps.Refresh(ctx, routes)
}

// GetRoute the network edge route.
// @MPI("mesh.net.edge")
func (that *meshPRSINetworkMPS) GetRoute(ctx context.Context, nodeId string) (*types.Route, error) {
	return that.mps.GetRoute(ctx, nodeId)
}

// GetRoutes the network edge routes.
// @MPI("mesh.net.edges")
func (that *meshPRSINetworkMPS) GetRoutes(ctx context.Context) ([]*types.Route, error) {
	return that.mps.GetRoutes(ctx)
}

// GetDomains the network domains.
// @MPI("mesh.net.domains")
func (that *meshPRSINetworkMPS) GetDomains(ctx context.Context, kind string) ([]*types.Domain, error) {
	return that.mps.GetDomains(ctx, kind)
}

// PutDomains the network domains.
// @MPI("mesh.net.resolve")
func (that *meshPRSINetworkMPS) PutDomains(ctx context.Context, kind string, domains []*types.Domain) error {
	return that.mps.PutDomains(ctx, kind, domains)
}

// Weave the network.
// @MPI("mesh.net.weave")
func (that *meshPRSINetworkMPS) Weave(ctx context.Context, route *types.Route) error {
	return that.mps.Weave(ctx, route)
}

// Ack the network.
// @MPI("mesh.net.ack")
func (that *meshPRSINetworkMPS) Ack(ctx context.Context, route *types.Route) error {
	return that.mps.Ack(ctx, route)
}

// Disable the network
// @MPI("mesh.net.disable")
func (that *meshPRSINetworkMPS) Disable(ctx context.Context, nodeId string) error {
	return that.mps.Disable(ctx, nodeId)
}

// Enable the network
// @MPI("mesh.net.enable")
func (that *meshPRSINetworkMPS) Enable(ctx context.Context, nodeId string) error {
	return that.mps.Enable(ctx, nodeId)
}

// Index the network edges
// @MPI("mesh.net.index")
func (that *meshPRSINetworkMPS) Index(ctx context.Context, index *types.Paging) (*types.Page[*types.Route], error) {
	return that.mps.Index(ctx, index)
}

// Version
// Network environment version.
// @MPI("mesh.net.version")
func (that *meshPRSINetworkMPS) Version(ctx context.Context, nodeId string) (*types.Versions, error) {
	return that.mps.Version(ctx, nodeId)
}

// Instx
// Network institutions.
// @MPI("mesh.net.instx")
func (that *meshPRSINetworkMPS) Instx(ctx context.Context, index *types.Paging) (*types.Page[*types.Institution], error) {
	return that.mps.Instx(ctx, index)
}

// Instr
// Network institutions.
// @MPI("mesh.net.instr")
func (that *meshPRSINetworkMPS) Instr(ctx context.Context, institutions []*types.Institution) error {
	return that.mps.Instr(ctx, institutions)
}

// Ally
// Network form alliance.
// @MPI("mesh.net.ally")
func (that *meshPRSINetworkMPS) Ally(ctx context.Context, nodeIds []string) error {
	return that.mps.Ally(ctx, nodeIds)
}

// Disband
// Network quit alliance.
// @MPI("mesh.net.disband")
func (that *meshPRSINetworkMPS) Disband(ctx context.Context, nodeIds []string) error {
	return that.mps.Disband(ctx, nodeIds)
}

// Assert
// Network feature assert.
// @MPI("mesh.net.assert")
func (that *meshPRSINetworkMPS) Assert(ctx context.Context, feature string, nodeIds []string) (bool, error) {
	return that.mps.Assert(ctx, feature, nodeIds)
}

type meshPRSINetworkGetEnvironMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkGetEnvironMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.environ", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkGetEnvironMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.environ", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkGetEnvironMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	return that.service.GetEnviron(ctx)
}

func (that *meshPRSINetworkGetEnvironMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	return that.service.GetEnviron(ctx)
}

type meshPRSINetworkAccessibleMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkAccessibleMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.accessible", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkAccessibleMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.accessible", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkAccessibleMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkAccessibleParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Accessible(ctx, parameters.Route)
}

func (that *meshPRSINetworkAccessibleMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkAccessibleParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Accessible(ctx, parameters.Route)
}

type meshPRSINetworkRefreshMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkRefreshMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.refresh", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkRefreshMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.refresh", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkRefreshMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkRefreshParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Refresh(ctx, parameters.Routes)
}

func (that *meshPRSINetworkRefreshMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkRefreshParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Refresh(ctx, parameters.Routes)
}

type meshPRSINetworkGetRouteMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkGetRouteMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.edge", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkGetRouteMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.edge", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkGetRouteMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkGetRouteParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.GetRoute(ctx, parameters.NodeId)
}

func (that *meshPRSINetworkGetRouteMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkGetRouteParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.GetRoute(ctx, parameters.NodeId)
}

type meshPRSINetworkGetRoutesMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkGetRoutesMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.edges", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkGetRoutesMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.edges", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkGetRoutesMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	return that.service.GetRoutes(ctx)
}

func (that *meshPRSINetworkGetRoutesMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	return that.service.GetRoutes(ctx)
}

type meshPRSINetworkGetDomainsMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkGetDomainsMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.domains", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkGetDomainsMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.domains", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkGetDomainsMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkGetDomainsParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.GetDomains(ctx, parameters.Kind)
}

func (that *meshPRSINetworkGetDomainsMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkGetDomainsParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.GetDomains(ctx, parameters.Kind)
}

type meshPRSINetworkPutDomainsMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkPutDomainsMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.resolve", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkPutDomainsMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.resolve", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkPutDomainsMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkPutDomainsParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.PutDomains(ctx, parameters.Kind, parameters.Domains)
}

func (that *meshPRSINetworkPutDomainsMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkPutDomainsParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.PutDomains(ctx, parameters.Kind, parameters.Domains)
}

type meshPRSINetworkWeaveMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkWeaveMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.weave", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkWeaveMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.weave", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkWeaveMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkWeaveParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Weave(ctx, parameters.Route)
}

func (that *meshPRSINetworkWeaveMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkWeaveParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Weave(ctx, parameters.Route)
}

type meshPRSINetworkAckMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkAckMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.ack", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkAckMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.ack", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkAckMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkAckParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Ack(ctx, parameters.Route)
}

func (that *meshPRSINetworkAckMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkAckParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Ack(ctx, parameters.Route)
}

type meshPRSINetworkDisableMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkDisableMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.disable", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkDisableMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.disable", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkDisableMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkDisableParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Disable(ctx, parameters.NodeId)
}

func (that *meshPRSINetworkDisableMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkDisableParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Disable(ctx, parameters.NodeId)
}

type meshPRSINetworkEnableMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkEnableMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.enable", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkEnableMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.enable", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkEnableMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkEnableParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Enable(ctx, parameters.NodeId)
}

func (that *meshPRSINetworkEnableMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkEnableParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Enable(ctx, parameters.NodeId)
}

type meshPRSINetworkIndexMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkIndexMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.index", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkIndexMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.index", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkIndexMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkIndexParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Index(ctx, parameters.Index)
}

func (that *meshPRSINetworkIndexMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkIndexParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Index(ctx, parameters.Index)
}

type meshPRSINetworkVersionMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkVersionMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.version", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkVersionMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.version", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkVersionMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkVersionParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Version(ctx, parameters.NodeId)
}

func (that *meshPRSINetworkVersionMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkVersionParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Version(ctx, parameters.NodeId)
}

type meshPRSINetworkInstxMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkInstxMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.instx", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkInstxMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.instx", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkInstxMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkInstxParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Instx(ctx, parameters.Index)
}

func (that *meshPRSINetworkInstxMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkInstxParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Instx(ctx, parameters.Index)
}

type meshPRSINetworkInstrMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkInstrMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.instr", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkInstrMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.instr", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkInstrMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkInstrParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Instr(ctx, parameters.Institutions)
}

func (that *meshPRSINetworkInstrMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkInstrParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Instr(ctx, parameters.Institutions)
}

type meshPRSINetworkAllyMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkAllyMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.ally", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkAllyMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.ally", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkAllyMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkAllyParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Ally(ctx, parameters.NodeIds)
}

func (that *meshPRSINetworkAllyMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkAllyParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Ally(ctx, parameters.NodeIds)
}

type meshPRSINetworkDisbandMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkDisbandMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.disband", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkDisbandMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.disband", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkDisbandMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkDisbandParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Disband(ctx, parameters.NodeIds)
}

func (that *meshPRSINetworkDisbandMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkDisbandParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Disband(ctx, parameters.NodeIds)
}

type meshPRSINetworkAssertMPS struct {
	service prsim.Network
}

func (that *meshPRSINetworkAssertMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.net.assert", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSINetworkAssertMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.net.assert", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSINetworkAssertMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshNetworkAssertParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Assert(ctx, parameters.Feature, parameters.NodeIds)
}

func (that *meshPRSINetworkAssertMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshNetworkAssertParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Assert(ctx, parameters.Feature, parameters.NodeIds)
}
