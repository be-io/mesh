/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"
	"strings"

	"github.com/opendatav/mesh/client/golang/cause"
	"github.com/opendatav/mesh/client/golang/macro"
	"github.com/opendatav/mesh/client/golang/mpc"
	proxympx "github.com/opendatav/mesh/client/golang/proxy"
	"github.com/opendatav/mesh/client/golang/prsim"
	"github.com/opendatav/mesh/client/golang/tool"
	"github.com/opendatav/mesh/client/golang/types"
	prsimmps "github.com/opendatav/mesh/plugin/prsim"
)

func init() {
	var service = &meshPRSISessionMPS{mps: new(prsimmps.PRSISession)}
	var _ prsim.Session = service
	macro.Provide((*prsim.Session)(nil), service)

	var servicePeek = &meshPRSISessionPeekMPS{service: service}
	var _ mpc.Invoker = servicePeek
	var _ macro.Caller = servicePeek
	macro.Provide(mpc.IInvoker, servicePeek)
	macro.Provide(macro.ICaller, servicePeek)

	var servicePop = &meshPRSISessionPopMPS{service: service}
	var _ mpc.Invoker = servicePop
	var _ macro.Caller = servicePop
	macro.Provide(mpc.IInvoker, servicePop)
	macro.Provide(macro.ICaller, servicePop)

	var servicePush = &meshPRSISessionPushMPS{service: service}
	var _ mpc.Invoker = servicePush
	var _ macro.Caller = servicePush
	macro.Provide(mpc.IInvoker, servicePush)
	macro.Provide(macro.ICaller, servicePush)

	var serviceRelease = &meshPRSISessionReleaseMPS{service: service}
	var _ mpc.Invoker = serviceRelease
	var _ macro.Caller = serviceRelease
	macro.Provide(mpc.IInvoker, serviceRelease)
	macro.Provide(macro.ICaller, serviceRelease)

}

// meshPRSISessionMPS is an implementation of prsim.PRSISession
type meshPRSISessionMPS struct {
	mps *prsimmps.PRSISession
}

func (that *meshPRSISessionMPS) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshSPI}
}

func (that *meshPRSISessionMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: macro.MeshMPS}
}

// Peek
// Retrieves, but does not remove, the head of this queue,
// or returns None if this queue is empty.
// @MPI("mesh.chan.peek")
func (that *meshPRSISessionMPS) Peek(ctx context.Context, topic string) ([]byte, error) {
	return that.mps.Peek(ctx, topic)
}

// Pop
// Retrieves and removes the head of this queue,
// or returns None if this queue is empty.
// @MPI("mesh.chan.pop")
func (that *meshPRSISessionMPS) Pop(ctx context.Context, timeout types.Duration, topic string) ([]byte, error) {
	return that.mps.Pop(ctx, timeout, topic)
}

// Push
// Inserts the specified element into this queue if it is possible to do
// so immediately without violating capacity restrictions.
// When using a capacity-restricted queue, this method is generally
// preferable to add, which can fail to insert an element only
// by throwing an exception.
// @MPI("mesh.chan.push")
func (that *meshPRSISessionMPS) Push(ctx context.Context, payload []byte, metadata map[string]string, topic string) error {
	return that.mps.Push(ctx, payload, metadata, topic)
}

// Release the channel session.
// @MPI("mesh.chan.release")
func (that *meshPRSISessionMPS) Release(ctx context.Context, timeout types.Duration, topic string) error {
	return that.mps.Release(ctx, timeout, topic)
}

type meshPRSISessionPeekMPS struct {
	service prsim.Session
}

func (that *meshPRSISessionPeekMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.chan.peek", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSISessionPeekMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.chan.peek", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSISessionPeekMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshSessionPeekParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Peek(ctx, parameters.Topic)
}

func (that *meshPRSISessionPeekMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshSessionPeekParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Peek(ctx, parameters.Topic)
}

type meshPRSISessionPopMPS struct {
	service prsim.Session
}

func (that *meshPRSISessionPopMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.chan.pop", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSISessionPopMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.chan.pop", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSISessionPopMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshSessionPopParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Pop(ctx, parameters.Timeout, parameters.Topic)
}

func (that *meshPRSISessionPopMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshSessionPopParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Pop(ctx, parameters.Timeout, parameters.Topic)
}

type meshPRSISessionPushMPS struct {
	service prsim.Session
}

func (that *meshPRSISessionPushMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.chan.push", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSISessionPushMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.chan.push", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSISessionPushMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshSessionPushParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Push(ctx, parameters.Payload, parameters.Metadata, parameters.Topic)
}

func (that *meshPRSISessionPushMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshSessionPushParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Push(ctx, parameters.Payload, parameters.Metadata, parameters.Topic)
}

type meshPRSISessionReleaseMPS struct {
	service prsim.Session
}

func (that *meshPRSISessionReleaseMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("mesh.chan.release", "${mesh.name}", tool.Name.Get())}
}
func (that *meshPRSISessionReleaseMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("mesh.chan.release", "${mesh.name}", tool.Name.Get())}
}

func (that *meshPRSISessionReleaseMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(proxympx.MeshSessionReleaseParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Release(ctx, parameters.Timeout, parameters.Topic)
}

func (that *meshPRSISessionReleaseMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*proxympx.MeshSessionReleaseParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Release(ctx, parameters.Timeout, parameters.Topic)
}
