// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: oauth2_token.sql

package dal

import "context"

const DeleteTokenMysql = `-- name: DeleteToken :exec
DELETE FROM ` + "`" + `oauth2_token` + "`" + ` WHERE ` + "`" + `code` + "`" + ` = ?
`

func (q *MysqlAccess) DeleteToken(ctx context.Context, code string) error {
	_, err := q.exec(ctx, q.deleteTokenStmt, DeleteTokenMysql, code)
	return err
}

const IndexTokenMysql = `-- name: IndexToken :many
SELECT code, access, refresh, data, create_at, expire_at FROM ` + "`" + `oauth2_token` + "`" + ` ORDER BY ` + "`" + `code` + "`" + ` ASC LIMIT ?, ?
`

func (q *MysqlAccess) IndexToken(ctx context.Context, arg *IndexTokenParams) ([]*Oauth2Token, error) {
	rows, err := q.query(ctx, q.indexTokenStmt, IndexTokenMysql, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Oauth2Token
	for rows.Next() {
		var i Oauth2Token
		if err := rows.Scan(
			&i.Code,
			&i.Access,
			&i.Refresh,
			&i.Data,
			&i.CreateAt,
			&i.ExpireAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertTokenMysql = `-- name: InsertToken :execrows
INSERT INTO ` + "`" + `oauth2_token` + "`" + ` (` + "`" + `create_at` + "`" + `, ` + "`" + `expire_at` + "`" + `, ` + "`" + `code` + "`" + `, ` + "`" + `access` + "`" + `, ` + "`" + `refresh` + "`" + `, ` + "`" + `data` + "`" + `)
VALUES (?, ?, ?, ?, ?, ?)
`

func (q *MysqlAccess) InsertToken(ctx context.Context, arg *InsertTokenParams) (int64, error) {
	result, err := q.exec(ctx, q.insertTokenStmt, InsertTokenMysql,
		arg.CreateAt,
		arg.ExpireAt,
		arg.Code,
		arg.Access,
		arg.Refresh,
		arg.Data,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
