// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0

package dal

import (
	"context"
	"database/sql"
	"fmt"
)

func NewMysql(db DBTX) *MysqlAccess {
	return &MysqlAccess{db: db}
}

func PrepareMysql(ctx context.Context, db DBTX) (*MysqlAccess, error) {
	q := MysqlAccess{db: db}
	var err error
	if q.deleteClientStmt, err = db.PrepareContext(ctx, DeleteClientMysql); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteClient: %w", err)
	}
	if q.deleteEdgeStmt, err = db.PrepareContext(ctx, DeleteEdgeMysql); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteEdge: %w", err)
	}
	if q.deleteKVStmt, err = db.PrepareContext(ctx, DeleteKVMysql); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteKV: %w", err)
	}
	if q.deleteTokenStmt, err = db.PrepareContext(ctx, DeleteTokenMysql); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteToken: %w", err)
	}
	if q.getSequenceByKindStmt, err = db.PrepareContext(ctx, GetSequenceByKindMysql); err != nil {
		return nil, fmt.Errorf("error preparing query GetSequenceByKind: %w", err)
	}
	if q.getSequenceByKindForUpdateStmt, err = db.PrepareContext(ctx, GetSequenceByKindForUpdateMysql); err != nil {
		return nil, fmt.Errorf("error preparing query GetSequenceByKindForUpdate: %w", err)
	}
	if q.indexClientStmt, err = db.PrepareContext(ctx, IndexClientMysql); err != nil {
		return nil, fmt.Errorf("error preparing query IndexClient: %w", err)
	}
	if q.indexEdgeStmt, err = db.PrepareContext(ctx, IndexEdgeMysql); err != nil {
		return nil, fmt.Errorf("error preparing query IndexEdge: %w", err)
	}
	if q.indexKVStmt, err = db.PrepareContext(ctx, IndexKVMysql); err != nil {
		return nil, fmt.Errorf("error preparing query IndexKV: %w", err)
	}
	if q.indexTokenStmt, err = db.PrepareContext(ctx, IndexTokenMysql); err != nil {
		return nil, fmt.Errorf("error preparing query IndexToken: %w", err)
	}
	if q.insertClientStmt, err = db.PrepareContext(ctx, InsertClientMysql); err != nil {
		return nil, fmt.Errorf("error preparing query InsertClient: %w", err)
	}
	if q.insertEdgeStmt, err = db.PrepareContext(ctx, InsertEdgeMysql); err != nil {
		return nil, fmt.Errorf("error preparing query InsertEdge: %w", err)
	}
	if q.insertKVStmt, err = db.PrepareContext(ctx, InsertKVMysql); err != nil {
		return nil, fmt.Errorf("error preparing query InsertKV: %w", err)
	}
	if q.insertSequenceStmt, err = db.PrepareContext(ctx, InsertSequenceMysql); err != nil {
		return nil, fmt.Errorf("error preparing query InsertSequence: %w", err)
	}
	if q.insertTokenStmt, err = db.PrepareContext(ctx, InsertTokenMysql); err != nil {
		return nil, fmt.Errorf("error preparing query InsertToken: %w", err)
	}
	if q.setSequenceMinStmt, err = db.PrepareContext(ctx, SetSequenceMinMysql); err != nil {
		return nil, fmt.Errorf("error preparing query SetSequenceMin: %w", err)
	}
	return &q, nil
}

func (q *MysqlAccess) Close() error {
	var err error
	if q.deleteClientStmt != nil {
		if cerr := q.deleteClientStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteClientStmt: %w", cerr)
		}
	}
	if q.deleteEdgeStmt != nil {
		if cerr := q.deleteEdgeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteEdgeStmt: %w", cerr)
		}
	}
	if q.deleteKVStmt != nil {
		if cerr := q.deleteKVStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteKVStmt: %w", cerr)
		}
	}
	if q.deleteTokenStmt != nil {
		if cerr := q.deleteTokenStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteTokenStmt: %w", cerr)
		}
	}
	if q.getSequenceByKindStmt != nil {
		if cerr := q.getSequenceByKindStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSequenceByKindStmt: %w", cerr)
		}
	}
	if q.getSequenceByKindForUpdateStmt != nil {
		if cerr := q.getSequenceByKindForUpdateStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSequenceByKindForUpdateStmt: %w", cerr)
		}
	}
	if q.indexClientStmt != nil {
		if cerr := q.indexClientStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing indexClientStmt: %w", cerr)
		}
	}
	if q.indexEdgeStmt != nil {
		if cerr := q.indexEdgeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing indexEdgeStmt: %w", cerr)
		}
	}
	if q.indexKVStmt != nil {
		if cerr := q.indexKVStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing indexKVStmt: %w", cerr)
		}
	}
	if q.indexTokenStmt != nil {
		if cerr := q.indexTokenStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing indexTokenStmt: %w", cerr)
		}
	}
	if q.insertClientStmt != nil {
		if cerr := q.insertClientStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertClientStmt: %w", cerr)
		}
	}
	if q.insertEdgeStmt != nil {
		if cerr := q.insertEdgeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertEdgeStmt: %w", cerr)
		}
	}
	if q.insertKVStmt != nil {
		if cerr := q.insertKVStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertKVStmt: %w", cerr)
		}
	}
	if q.insertSequenceStmt != nil {
		if cerr := q.insertSequenceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertSequenceStmt: %w", cerr)
		}
	}
	if q.insertTokenStmt != nil {
		if cerr := q.insertTokenStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertTokenStmt: %w", cerr)
		}
	}
	if q.setSequenceMinStmt != nil {
		if cerr := q.setSequenceMinStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing setSequenceMinStmt: %w", cerr)
		}
	}
	return err
}

func (q *MysqlAccess) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *MysqlAccess) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *MysqlAccess) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type MysqlAccess struct {
	db                             DBTX
	tx                             *sql.Tx
	deleteClientStmt               *sql.Stmt
	deleteEdgeStmt                 *sql.Stmt
	deleteKVStmt                   *sql.Stmt
	deleteTokenStmt                *sql.Stmt
	getSequenceByKindStmt          *sql.Stmt
	getSequenceByKindForUpdateStmt *sql.Stmt
	indexClientStmt                *sql.Stmt
	indexEdgeStmt                  *sql.Stmt
	indexKVStmt                    *sql.Stmt
	indexTokenStmt                 *sql.Stmt
	insertClientStmt               *sql.Stmt
	insertEdgeStmt                 *sql.Stmt
	insertKVStmt                   *sql.Stmt
	insertSequenceStmt             *sql.Stmt
	insertTokenStmt                *sql.Stmt
	setSequenceMinStmt             *sql.Stmt
}

func (q *MysqlAccess) WithTx(tx *sql.Tx) *MysqlAccess {
	return &MysqlAccess{
		db:                             tx,
		tx:                             tx,
		deleteClientStmt:               q.deleteClientStmt,
		deleteEdgeStmt:                 q.deleteEdgeStmt,
		deleteKVStmt:                   q.deleteKVStmt,
		deleteTokenStmt:                q.deleteTokenStmt,
		getSequenceByKindStmt:          q.getSequenceByKindStmt,
		getSequenceByKindForUpdateStmt: q.getSequenceByKindForUpdateStmt,
		indexClientStmt:                q.indexClientStmt,
		indexEdgeStmt:                  q.indexEdgeStmt,
		indexKVStmt:                    q.indexKVStmt,
		indexTokenStmt:                 q.indexTokenStmt,
		insertClientStmt:               q.insertClientStmt,
		insertEdgeStmt:                 q.insertEdgeStmt,
		insertKVStmt:                   q.insertKVStmt,
		insertSequenceStmt:             q.insertSequenceStmt,
		insertTokenStmt:                q.insertTokenStmt,
		setSequenceMinStmt:             q.setSequenceMinStmt,
	}
}
