// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: sequence.sql

package dal

import "context"

const GetSequenceByKindMysql = `-- name: GetSequenceByKind :one
SELECT kind, min, max, size, length, status, version, create_at, update_at FROM ` + "`" + `sequence` + "`" + ` WHERE ` + "`" + `kind` + "`" + ` = ?
`

func (q *MysqlAccess) GetSequenceByKind(ctx context.Context, kind string) (*Sequence, error) {
	row := q.queryRow(ctx, q.getSequenceByKindStmt, GetSequenceByKindMysql, kind)
	var i Sequence
	err := row.Scan(
		&i.Kind,
		&i.Min,
		&i.Max,
		&i.Size,
		&i.Length,
		&i.Status,
		&i.Version,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return &i, err
}

const GetSequenceByKindForUpdateMysql = `-- name: GetSequenceByKindForUpdate :one
SELECT kind, min, max, size, length, status, version, create_at, update_at FROM ` + "`" + `sequence` + "`" + ` WHERE ` + "`" + `kind` + "`" + ` = ? FOR UPDATE
`

func (q *MysqlAccess) GetSequenceByKindForUpdate(ctx context.Context, kind string) (*Sequence, error) {
	row := q.queryRow(ctx, q.getSequenceByKindForUpdateStmt, GetSequenceByKindForUpdateMysql, kind)
	var i Sequence
	err := row.Scan(
		&i.Kind,
		&i.Min,
		&i.Max,
		&i.Size,
		&i.Length,
		&i.Status,
		&i.Version,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return &i, err
}

const InsertSequenceMysql = `-- name: InsertSequence :execrows
INSERT INTO ` + "`" + `sequence` + "`" + ` (` + "`" + `kind` + "`" + `, ` + "`" + `min` + "`" + `, ` + "`" + `max` + "`" + `, ` + "`" + `size` + "`" + `, ` + "`" + `length` + "`" + `, ` + "`" + `status` + "`" + `, ` + "`" + `version` + "`" + `, ` + "`" + `create_at` + "`" + `, ` + "`" + `update_at` + "`" + `)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

func (q *MysqlAccess) InsertSequence(ctx context.Context, arg *InsertSequenceParams) (int64, error) {
	result, err := q.exec(ctx, q.insertSequenceStmt, InsertSequenceMysql,
		arg.Kind,
		arg.Min,
		arg.Max,
		arg.Size,
		arg.Length,
		arg.Status,
		arg.Version,
		arg.CreateAt,
		arg.UpdateAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const SetSequenceMinMysql = `-- name: SetSequenceMin :execrows
UPDATE ` + "`" + `sequence` + "`" + ` SET ` + "`" + `min` + "`" + ` = ?, ` + "`" + `version` + "`" + ` = ` + "`" + `version` + "`" + ` + 1 WHERE ` + "`" + `kind` + "`" + ` = ? AND ` + "`" + `version` + "`" + ` = ?
`

func (q *MysqlAccess) SetSequenceMin(ctx context.Context, arg *SetSequenceMinParams) (int64, error) {
	result, err := q.exec(ctx, q.setSequenceMinStmt, SetSequenceMinMysql, arg.Min, arg.Kind, arg.Version)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
