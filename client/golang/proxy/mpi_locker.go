/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"
	"time"

	"github.com/be-io/mesh/client/golang/cause"
	"github.com/be-io/mesh/client/golang/macro"
	"github.com/be-io/mesh/client/golang/mpc"
	"github.com/be-io/mesh/client/golang/prsim"
)

func init() {
	var _ macro.Interface = new(meshLockerMPI)
	macro.Provide((*prsim.Locker)(nil), &meshLockerMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Lock": {
				DeclaredKind: (*prsim.Locker)(nil),
				TName:        "prsim.Locker",
				Name:         "Lock",
				Intype:       func() macro.Parameters { var parameters MeshLockerLockParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshLockerLockReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshLockerLockParameters) },
				Outbound:     func() macro.Returns { return new(MeshLockerLockReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.locker.w.lock"},
				},
			},
			"Unlock": {
				DeclaredKind: (*prsim.Locker)(nil),
				TName:        "prsim.Locker",
				Name:         "Unlock",
				Intype:       func() macro.Parameters { var parameters MeshLockerUnlockParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshLockerUnlockReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshLockerUnlockParameters) },
				Outbound:     func() macro.Returns { return new(MeshLockerUnlockReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.locker.w.unlock"},
				},
			},
			"ReadLock": {
				DeclaredKind: (*prsim.Locker)(nil),
				TName:        "prsim.Locker",
				Name:         "ReadLock",
				Intype:       func() macro.Parameters { var parameters MeshLockerReadLockParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshLockerReadLockReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshLockerReadLockParameters) },
				Outbound:     func() macro.Returns { return new(MeshLockerReadLockReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.locker.r.lock"},
				},
			},
			"ReadUnlock": {
				DeclaredKind: (*prsim.Locker)(nil),
				TName:        "prsim.Locker",
				Name:         "ReadUnlock",
				Intype:       func() macro.Parameters { var parameters MeshLockerReadUnlockParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshLockerReadUnlockReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshLockerReadUnlockParameters) },
				Outbound:     func() macro.Returns { return new(MeshLockerReadUnlockReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.locker.r.unlock"},
				},
			},
		},
	})
}

// meshLockerMPI is an implementation of Locker
type meshLockerMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshLockerMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshLockerMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshLockerMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Lock create write lock.
// @MPI("mesh.locker.w.lock")
func (that *meshLockerMPI) Lock(ctx context.Context, rid string, timeout time.Duration) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Lock"], rid, timeout)
	if nil != err {
		x := new(MeshLockerLockReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshLockerLockReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshLockerLockReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Unlock release write lock.
// @MPI("mesh.locker.w.unlock")
func (that *meshLockerMPI) Unlock(ctx context.Context, rid string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Unlock"], rid)
	return err
}

// ReadLock create read lock.
// @MPI("mesh.locker.r.lock")
func (that *meshLockerMPI) ReadLock(ctx context.Context, rid string, timeout time.Duration) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["ReadLock"], rid, timeout)
	if nil != err {
		x := new(MeshLockerReadLockReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshLockerReadLockReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshLockerReadLockReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// ReadUnlock release read lock.
// @MPI("mesh.locker.r.unlock")
func (that *meshLockerMPI) ReadUnlock(ctx context.Context, rid string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["ReadUnlock"], rid)
	return err
}

type MeshLockerLockParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Rid         string            `index:"0" json:"rid" xml:"rid" yaml:"rid"`
	Timeout     time.Duration     `index:"1" json:"timeout" xml:"timeout" yaml:"timeout"`
}

func (that *MeshLockerLockParameters) GetKind() interface{} {
	return new(MeshLockerLockParameters)
}

func (that *MeshLockerLockParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Rid)
	arguments = append(arguments, that.Timeout)
	return arguments
}

func (that *MeshLockerLockParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Rid = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Timeout = arguments[1].(time.Duration)
		}
	}
}

func (that *MeshLockerLockParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshLockerLockParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshLockerLockReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshLockerLockReturns) GetCode() string {
	return that.Code
}

func (that *MeshLockerLockReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshLockerLockReturns) GetMessage() string {
	return that.Message
}

func (that *MeshLockerLockReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshLockerLockReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshLockerLockReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshLockerLockReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshLockerLockReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}

type MeshLockerUnlockParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Rid         string            `index:"0" json:"rid" xml:"rid" yaml:"rid"`
}

func (that *MeshLockerUnlockParameters) GetKind() interface{} {
	return new(MeshLockerUnlockParameters)
}

func (that *MeshLockerUnlockParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Rid)
	return arguments
}

func (that *MeshLockerUnlockParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Rid = arguments[0].(string)
		}
	}
}

func (that *MeshLockerUnlockParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshLockerUnlockParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshLockerUnlockReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshLockerUnlockReturns) GetCode() string {
	return that.Code
}

func (that *MeshLockerUnlockReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshLockerUnlockReturns) GetMessage() string {
	return that.Message
}

func (that *MeshLockerUnlockReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshLockerUnlockReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshLockerUnlockReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshLockerUnlockReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshLockerUnlockReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshLockerReadLockParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Rid         string            `index:"0" json:"rid" xml:"rid" yaml:"rid"`
	Timeout     time.Duration     `index:"1" json:"timeout" xml:"timeout" yaml:"timeout"`
}

func (that *MeshLockerReadLockParameters) GetKind() interface{} {
	return new(MeshLockerReadLockParameters)
}

func (that *MeshLockerReadLockParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Rid)
	arguments = append(arguments, that.Timeout)
	return arguments
}

func (that *MeshLockerReadLockParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Rid = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Timeout = arguments[1].(time.Duration)
		}
	}
}

func (that *MeshLockerReadLockParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshLockerReadLockParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshLockerReadLockReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshLockerReadLockReturns) GetCode() string {
	return that.Code
}

func (that *MeshLockerReadLockReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshLockerReadLockReturns) GetMessage() string {
	return that.Message
}

func (that *MeshLockerReadLockReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshLockerReadLockReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshLockerReadLockReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshLockerReadLockReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshLockerReadLockReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}

type MeshLockerReadUnlockParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Rid         string            `index:"0" json:"rid" xml:"rid" yaml:"rid"`
}

func (that *MeshLockerReadUnlockParameters) GetKind() interface{} {
	return new(MeshLockerReadUnlockParameters)
}

func (that *MeshLockerReadUnlockParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Rid)
	return arguments
}

func (that *MeshLockerReadUnlockParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Rid = arguments[0].(string)
		}
	}
}

func (that *MeshLockerReadUnlockParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshLockerReadUnlockParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshLockerReadUnlockReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshLockerReadUnlockReturns) GetCode() string {
	return that.Code
}

func (that *MeshLockerReadUnlockReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshLockerReadUnlockReturns) GetMessage() string {
	return that.Message
}

func (that *MeshLockerReadUnlockReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshLockerReadUnlockReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshLockerReadUnlockReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshLockerReadUnlockReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshLockerReadUnlockReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}
