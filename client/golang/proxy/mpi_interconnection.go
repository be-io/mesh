/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"

	"github.com/be-io/mesh/client/golang/cause"
	"github.com/be-io/mesh/client/golang/macro"
	"github.com/be-io/mesh/client/golang/mpc"
	"github.com/be-io/mesh/client/golang/prsim"
	"github.com/be-io/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshInterconnectionMPI)
	macro.Provide((*prsim.Interconnection)(nil), &meshInterconnectionMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Instx": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Instx",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionInstxParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionInstxReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionInstxParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionInstxReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.inc.instx"},
				},
			},
			"ContractIds": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "ContractIds",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionContractIdsParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionContractIdsReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionContractIdsParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionContractIdsReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.inc.contract.ids"},
				},
			},
			"Contract": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Contract",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionContractParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionContractReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionContractParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionContractReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.inc.contract"},
				},
			},
			"Describe": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Describe",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionDescribeParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionDescribeReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionDescribeParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionDescribeReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Flags: 8, Name: "mesh.inc.describe"},
				},
			},
			"Weave": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Weave",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionWeaveParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionWeaveReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionWeaveParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionWeaveReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Flags: 8, Name: "mesh.inc.weave"},
				},
			},
			"Ack": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Ack",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionAckParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionAckReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionAckParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionAckReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Flags: 8, Name: "mesh.inc.ack"},
				},
			},
			"Abort": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Abort",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionAbortParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionAbortReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionAbortParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionAbortReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Flags: 8, Name: "mesh.inc.abort"},
				},
			},
			"Refresh": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Refresh",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionRefreshParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionRefreshReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionRefreshParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionRefreshReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Flags: 8, Name: "mesh.inc.refresh"},
				},
			},
			"Probe": {
				DeclaredKind: (*prsim.Interconnection)(nil),
				TName:        "prsim.Interconnection",
				Name:         "Probe",
				Intype:       func() macro.Parameters { var parameters MeshInterconnectionProbeParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshInterconnectionProbeReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshInterconnectionProbeParameters) },
				Outbound:     func() macro.Returns { return new(MeshInterconnectionProbeReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Flags: 8, Name: "mesh.inc.probe"},
				},
			},
		},
	})
}

// meshInterconnectionMPI is an implementation of Interconnection
type meshInterconnectionMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshInterconnectionMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshInterconnectionMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshInterconnectionMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Instx apply institutions by contract id.
// @MPI("mesh.inc.instx")
func (that *meshInterconnectionMPI) Instx(ctx context.Context, contractId string) ([]*types.Institution, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Instx"], contractId)
	if nil != err {
		x := new(MeshInterconnectionInstxReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionInstxReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionInstxReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// ContractIds infer the contract ids by institution ids.
// @MPI("mesh.inc.contract.ids")
func (that *meshInterconnectionMPI) ContractIds(ctx context.Context, instIds []string) ([]string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["ContractIds"], instIds)
	if nil != err {
		x := new(MeshInterconnectionContractIdsReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionContractIdsReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionContractIdsReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Contract /v1/interconn/node/contract/query
// APPLIED已申请
// APPROVED已授权
// REJECTED已拒绝
// TERMINATED已解除
// @MPI("mesh.inc.contract")
func (that *meshInterconnectionMPI) Contract(ctx context.Context, req *prsim.IncContractID) (*prsim.IncState, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Contract"], req)
	if nil != err {
		x := new(MeshInterconnectionContractReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionContractReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionContractReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Describe /v1/interconn/node/query  /v1/platform/node/query
// @MPI(name = "mesh.inc.describe", flags = 8)
func (that *meshInterconnectionMPI) Describe(ctx context.Context, req *prsim.IncNodeID) (*prsim.IncNode, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Describe"], req)
	if nil != err {
		x := new(MeshInterconnectionDescribeReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionDescribeReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionDescribeReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Weave /v1/interconn/node/contract/apply
// @MPI(name = "mesh.inc.weave", flags = 8)
func (that *meshInterconnectionMPI) Weave(ctx context.Context, req *prsim.IncNode) (*prsim.IncContractID, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Weave"], req)
	if nil != err {
		x := new(MeshInterconnectionWeaveReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionWeaveReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionWeaveReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Ack /v1/interconn/node/contract/confirm
// @MPI(name = "mesh.inc.ack", flags = 8)
func (that *meshInterconnectionMPI) Ack(ctx context.Context, req *prsim.IncAck) (*prsim.IncOption, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Ack"], req)
	if nil != err {
		x := new(MeshInterconnectionAckReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionAckReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionAckReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Abort /v1/interconn/node/contract/terminate
// @MPI(name = "mesh.inc.abort", flags = 8)
func (that *meshInterconnectionMPI) Abort(ctx context.Context, req *prsim.IncContractID) (*prsim.IncOption, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Abort"], req)
	if nil != err {
		x := new(MeshInterconnectionAbortReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionAbortReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionAbortReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Refresh /v1/interconn/node/update /v1/platform/node/update
// @MPI(name = "mesh.inc.refresh", flags = 8)
func (that *meshInterconnectionMPI) Refresh(ctx context.Context, req *prsim.IncNode) (*prsim.IncOption, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Refresh"], req)
	if nil != err {
		x := new(MeshInterconnectionRefreshReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionRefreshReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionRefreshReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Probe /v1/interconn/node/health
// 节点健康状态。直接返回ok
// @MPI(name = "mesh.inc.probe", flags = 8)
func (that *meshInterconnectionMPI) Probe(ctx context.Context, req *prsim.IncOption) (*prsim.IncState, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Probe"], req)
	if nil != err {
		x := new(MeshInterconnectionProbeReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshInterconnectionProbeReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshInterconnectionProbeReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

type MeshInterconnectionInstxParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	ContractId  string            `index:"0" json:"contract_id" xml:"contract_id" yaml:"contract_id"`
}

func (that *MeshInterconnectionInstxParameters) GetKind() interface{} {
	return new(MeshInterconnectionInstxParameters)
}

func (that *MeshInterconnectionInstxParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.ContractId)
	return arguments
}

func (that *MeshInterconnectionInstxParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.ContractId = arguments[0].(string)
		}
	}
}

func (that *MeshInterconnectionInstxParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionInstxParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionInstxReturns struct {
	Code    string               `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string               `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause         `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []*types.Institution `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionInstxReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionInstxReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionInstxReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionInstxReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionInstxReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionInstxReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionInstxReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionInstxReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]*types.Institution)
		}
	}
}

type MeshInterconnectionContractIdsParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	InstIds     []string          `index:"0" json:"inst_ids" xml:"inst_ids" yaml:"inst_ids"`
}

func (that *MeshInterconnectionContractIdsParameters) GetKind() interface{} {
	return new(MeshInterconnectionContractIdsParameters)
}

func (that *MeshInterconnectionContractIdsParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.InstIds)
	return arguments
}

func (that *MeshInterconnectionContractIdsParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.InstIds = arguments[0].([]string)
		}
	}
}

func (that *MeshInterconnectionContractIdsParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionContractIdsParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionContractIdsReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []string     `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionContractIdsReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionContractIdsReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionContractIdsReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionContractIdsReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionContractIdsReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionContractIdsReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionContractIdsReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionContractIdsReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]string)
		}
	}
}

type MeshInterconnectionContractParameters struct {
	Attachments map[string]string    `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Req         *prsim.IncContractID `index:"0" json:"req" xml:"req" yaml:"req"`
}

func (that *MeshInterconnectionContractParameters) GetKind() interface{} {
	return new(MeshInterconnectionContractParameters)
}

func (that *MeshInterconnectionContractParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Req)
	return arguments
}

func (that *MeshInterconnectionContractParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Req = arguments[0].(*prsim.IncContractID)
		}
	}
}

func (that *MeshInterconnectionContractParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionContractParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionContractReturns struct {
	Code    string          `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string          `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause    `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *prsim.IncState `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionContractReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionContractReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionContractReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionContractReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionContractReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionContractReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionContractReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionContractReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*prsim.IncState)
		}
	}
}

type MeshInterconnectionDescribeParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Req         *prsim.IncNodeID  `index:"0" json:"req" xml:"req" yaml:"req"`
}

func (that *MeshInterconnectionDescribeParameters) GetKind() interface{} {
	return new(MeshInterconnectionDescribeParameters)
}

func (that *MeshInterconnectionDescribeParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Req)
	return arguments
}

func (that *MeshInterconnectionDescribeParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Req = arguments[0].(*prsim.IncNodeID)
		}
	}
}

func (that *MeshInterconnectionDescribeParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionDescribeParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionDescribeReturns struct {
	Code    string         `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string         `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause   `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *prsim.IncNode `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionDescribeReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionDescribeReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionDescribeReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionDescribeReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionDescribeReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionDescribeReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionDescribeReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionDescribeReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*prsim.IncNode)
		}
	}
}

type MeshInterconnectionWeaveParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Req         *prsim.IncNode    `index:"0" json:"req" xml:"req" yaml:"req"`
}

func (that *MeshInterconnectionWeaveParameters) GetKind() interface{} {
	return new(MeshInterconnectionWeaveParameters)
}

func (that *MeshInterconnectionWeaveParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Req)
	return arguments
}

func (that *MeshInterconnectionWeaveParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Req = arguments[0].(*prsim.IncNode)
		}
	}
}

func (that *MeshInterconnectionWeaveParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionWeaveParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionWeaveReturns struct {
	Code    string               `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string               `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause         `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *prsim.IncContractID `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionWeaveReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionWeaveReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionWeaveReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionWeaveReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionWeaveReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionWeaveReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionWeaveReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionWeaveReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*prsim.IncContractID)
		}
	}
}

type MeshInterconnectionAckParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Req         *prsim.IncAck     `index:"0" json:"req" xml:"req" yaml:"req"`
}

func (that *MeshInterconnectionAckParameters) GetKind() interface{} {
	return new(MeshInterconnectionAckParameters)
}

func (that *MeshInterconnectionAckParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Req)
	return arguments
}

func (that *MeshInterconnectionAckParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Req = arguments[0].(*prsim.IncAck)
		}
	}
}

func (that *MeshInterconnectionAckParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionAckParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionAckReturns struct {
	Code    string           `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string           `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause     `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *prsim.IncOption `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionAckReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionAckReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionAckReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionAckReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionAckReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionAckReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionAckReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionAckReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*prsim.IncOption)
		}
	}
}

type MeshInterconnectionAbortParameters struct {
	Attachments map[string]string    `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Req         *prsim.IncContractID `index:"0" json:"req" xml:"req" yaml:"req"`
}

func (that *MeshInterconnectionAbortParameters) GetKind() interface{} {
	return new(MeshInterconnectionAbortParameters)
}

func (that *MeshInterconnectionAbortParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Req)
	return arguments
}

func (that *MeshInterconnectionAbortParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Req = arguments[0].(*prsim.IncContractID)
		}
	}
}

func (that *MeshInterconnectionAbortParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionAbortParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionAbortReturns struct {
	Code    string           `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string           `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause     `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *prsim.IncOption `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionAbortReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionAbortReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionAbortReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionAbortReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionAbortReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionAbortReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionAbortReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionAbortReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*prsim.IncOption)
		}
	}
}

type MeshInterconnectionRefreshParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Req         *prsim.IncNode    `index:"0" json:"req" xml:"req" yaml:"req"`
}

func (that *MeshInterconnectionRefreshParameters) GetKind() interface{} {
	return new(MeshInterconnectionRefreshParameters)
}

func (that *MeshInterconnectionRefreshParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Req)
	return arguments
}

func (that *MeshInterconnectionRefreshParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Req = arguments[0].(*prsim.IncNode)
		}
	}
}

func (that *MeshInterconnectionRefreshParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionRefreshParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionRefreshReturns struct {
	Code    string           `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string           `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause     `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *prsim.IncOption `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionRefreshReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionRefreshReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionRefreshReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionRefreshReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionRefreshReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionRefreshReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionRefreshReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionRefreshReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*prsim.IncOption)
		}
	}
}

type MeshInterconnectionProbeParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Req         *prsim.IncOption  `index:"0" json:"req" xml:"req" yaml:"req"`
}

func (that *MeshInterconnectionProbeParameters) GetKind() interface{} {
	return new(MeshInterconnectionProbeParameters)
}

func (that *MeshInterconnectionProbeParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Req)
	return arguments
}

func (that *MeshInterconnectionProbeParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Req = arguments[0].(*prsim.IncOption)
		}
	}
}

func (that *MeshInterconnectionProbeParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshInterconnectionProbeParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshInterconnectionProbeReturns struct {
	Code    string          `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string          `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause    `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *prsim.IncState `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshInterconnectionProbeReturns) GetCode() string {
	return that.Code
}

func (that *MeshInterconnectionProbeReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshInterconnectionProbeReturns) GetMessage() string {
	return that.Message
}

func (that *MeshInterconnectionProbeReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshInterconnectionProbeReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshInterconnectionProbeReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshInterconnectionProbeReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshInterconnectionProbeReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*prsim.IncState)
		}
	}
}
