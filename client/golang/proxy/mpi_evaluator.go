/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"

	"github.com/opendatav/mesh/client/golang/cause"
	"github.com/opendatav/mesh/client/golang/macro"
	"github.com/opendatav/mesh/client/golang/mpc"
	"github.com/opendatav/mesh/client/golang/prsim"
	"github.com/opendatav/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshEvaluatorMPI)
	macro.Provide((*prsim.Evaluator)(nil), &meshEvaluatorMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Compile": {
				DeclaredKind: (*prsim.Evaluator)(nil),
				TName:        "prsim.Evaluator",
				Name:         "Compile",
				Intype:       func() macro.Parameters { var parameters MeshEvaluatorCompileParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshEvaluatorCompileReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshEvaluatorCompileParameters) },
				Outbound:     func() macro.Returns { return new(MeshEvaluatorCompileReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.eval.compile"},
				},
			},
			"Exec": {
				DeclaredKind: (*prsim.Evaluator)(nil),
				TName:        "prsim.Evaluator",
				Name:         "Exec",
				Intype:       func() macro.Parameters { var parameters MeshEvaluatorExecParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshEvaluatorExecReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshEvaluatorExecParameters) },
				Outbound:     func() macro.Returns { return new(MeshEvaluatorExecReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.eval.exec"},
				},
			},
			"Dump": {
				DeclaredKind: (*prsim.Evaluator)(nil),
				TName:        "prsim.Evaluator",
				Name:         "Dump",
				Intype:       func() macro.Parameters { var parameters MeshEvaluatorDumpParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshEvaluatorDumpReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshEvaluatorDumpParameters) },
				Outbound:     func() macro.Returns { return new(MeshEvaluatorDumpReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.eval.dump"},
				},
			},
			"Index": {
				DeclaredKind: (*prsim.Evaluator)(nil),
				TName:        "prsim.Evaluator",
				Name:         "Index",
				Intype:       func() macro.Parameters { var parameters MeshEvaluatorIndexParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshEvaluatorIndexReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshEvaluatorIndexParameters) },
				Outbound:     func() macro.Returns { return new(MeshEvaluatorIndexReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.eval.index"},
				},
			},
		},
	})
}

// meshEvaluatorMPI is an implementation of Evaluator
type meshEvaluatorMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshEvaluatorMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshEvaluatorMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshEvaluatorMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Compile the named rule.
// @MPI("mesh.eval.compile")
func (that *meshEvaluatorMPI) Compile(ctx context.Context, script *types.Script) (string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Compile"], script)
	if nil != err {
		x := new(MeshEvaluatorCompileReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshEvaluatorCompileReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshEvaluatorCompileReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Exec the script with name.
// @MPI("mesh.eval.exec")
func (that *meshEvaluatorMPI) Exec(ctx context.Context, code string, args map[string]string, dft string) (string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Exec"], code, args, dft)
	if nil != err {
		x := new(MeshEvaluatorExecReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshEvaluatorExecReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshEvaluatorExecReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Dump the scripts.
// @MPI("mesh.eval.dump")
func (that *meshEvaluatorMPI) Dump(ctx context.Context, feature map[string]string) ([]*types.Script, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Dump"], feature)
	if nil != err {
		x := new(MeshEvaluatorDumpReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshEvaluatorDumpReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshEvaluatorDumpReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Index the scripts.
// @MPI("mesh.eval.index")
func (that *meshEvaluatorMPI) Index(ctx context.Context, index *types.Paging) (*types.Page[*types.Script], error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Index"], index)
	if nil != err {
		x := new(MeshEvaluatorIndexReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshEvaluatorIndexReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshEvaluatorIndexReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

type MeshEvaluatorCompileParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Script      *types.Script     `index:"0" json:"script" xml:"script" yaml:"script"`
}

func (that *MeshEvaluatorCompileParameters) GetKind() interface{} {
	return new(MeshEvaluatorCompileParameters)
}

func (that *MeshEvaluatorCompileParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Script)
	return arguments
}

func (that *MeshEvaluatorCompileParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Script = arguments[0].(*types.Script)
		}
	}
}

func (that *MeshEvaluatorCompileParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshEvaluatorCompileParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshEvaluatorCompileReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content string       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshEvaluatorCompileReturns) GetCode() string {
	return that.Code
}

func (that *MeshEvaluatorCompileReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshEvaluatorCompileReturns) GetMessage() string {
	return that.Message
}

func (that *MeshEvaluatorCompileReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshEvaluatorCompileReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshEvaluatorCompileReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshEvaluatorCompileReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshEvaluatorCompileReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(string)
		}
	}
}

type MeshEvaluatorExecParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Code        string            `index:"0" json:"code" xml:"code" yaml:"code"`
	Args        map[string]string `index:"1" json:"args" xml:"args" yaml:"args"`
	Dft         string            `index:"2" json:"dft" xml:"dft" yaml:"dft"`
}

func (that *MeshEvaluatorExecParameters) GetKind() interface{} {
	return new(MeshEvaluatorExecParameters)
}

func (that *MeshEvaluatorExecParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Code)
	arguments = append(arguments, that.Args)
	arguments = append(arguments, that.Dft)
	return arguments
}

func (that *MeshEvaluatorExecParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Code = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Args = arguments[1].(map[string]string)
		}
		if len(arguments) > 2 && nil != arguments[2] {
			that.Dft = arguments[2].(string)
		}
	}
}

func (that *MeshEvaluatorExecParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshEvaluatorExecParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshEvaluatorExecReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content string       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshEvaluatorExecReturns) GetCode() string {
	return that.Code
}

func (that *MeshEvaluatorExecReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshEvaluatorExecReturns) GetMessage() string {
	return that.Message
}

func (that *MeshEvaluatorExecReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshEvaluatorExecReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshEvaluatorExecReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshEvaluatorExecReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshEvaluatorExecReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(string)
		}
	}
}

type MeshEvaluatorDumpParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Feature     map[string]string `index:"0" json:"feature" xml:"feature" yaml:"feature"`
}

func (that *MeshEvaluatorDumpParameters) GetKind() interface{} {
	return new(MeshEvaluatorDumpParameters)
}

func (that *MeshEvaluatorDumpParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Feature)
	return arguments
}

func (that *MeshEvaluatorDumpParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Feature = arguments[0].(map[string]string)
		}
	}
}

func (that *MeshEvaluatorDumpParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshEvaluatorDumpParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshEvaluatorDumpReturns struct {
	Code    string          `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string          `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause    `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []*types.Script `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshEvaluatorDumpReturns) GetCode() string {
	return that.Code
}

func (that *MeshEvaluatorDumpReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshEvaluatorDumpReturns) GetMessage() string {
	return that.Message
}

func (that *MeshEvaluatorDumpReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshEvaluatorDumpReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshEvaluatorDumpReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshEvaluatorDumpReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshEvaluatorDumpReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]*types.Script)
		}
	}
}

type MeshEvaluatorIndexParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Index       *types.Paging     `index:"0" json:"index" xml:"index" yaml:"index"`
}

func (that *MeshEvaluatorIndexParameters) GetKind() interface{} {
	return new(MeshEvaluatorIndexParameters)
}

func (that *MeshEvaluatorIndexParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Index)
	return arguments
}

func (that *MeshEvaluatorIndexParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Index = arguments[0].(*types.Paging)
		}
	}
}

func (that *MeshEvaluatorIndexParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshEvaluatorIndexParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshEvaluatorIndexReturns struct {
	Code    string                     `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string                     `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause               `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Page[*types.Script] `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshEvaluatorIndexReturns) GetCode() string {
	return that.Code
}

func (that *MeshEvaluatorIndexReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshEvaluatorIndexReturns) GetMessage() string {
	return that.Message
}

func (that *MeshEvaluatorIndexReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshEvaluatorIndexReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshEvaluatorIndexReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshEvaluatorIndexReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshEvaluatorIndexReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Page[*types.Script])
		}
	}
}
