/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"

	"github.com/be-io/mesh/client/golang/cause"
	"github.com/be-io/mesh/client/golang/macro"
	"github.com/be-io/mesh/client/golang/mpc"
	"github.com/be-io/mesh/client/golang/prsim"
	"github.com/be-io/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshCommercializeMPI)
	macro.Provide((*prsim.Commercialize)(nil), &meshCommercializeMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Sign": {
				DeclaredKind: (*prsim.Commercialize)(nil),
				TName:        "prsim.Commercialize",
				Name:         "Sign",
				Intype:       func() macro.Parameters { var parameters MeshCommercializeSignParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCommercializeSignReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCommercializeSignParameters) },
				Outbound:     func() macro.Returns { return new(MeshCommercializeSignReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.license.sign"},
				},
			},
			"History": {
				DeclaredKind: (*prsim.Commercialize)(nil),
				TName:        "prsim.Commercialize",
				Name:         "History",
				Intype:       func() macro.Parameters { var parameters MeshCommercializeHistoryParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCommercializeHistoryReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCommercializeHistoryParameters) },
				Outbound:     func() macro.Returns { return new(MeshCommercializeHistoryReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.license.history"},
				},
			},
			"Issued": {
				DeclaredKind: (*prsim.Commercialize)(nil),
				TName:        "prsim.Commercialize",
				Name:         "Issued",
				Intype:       func() macro.Parameters { var parameters MeshCommercializeIssuedParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCommercializeIssuedReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCommercializeIssuedParameters) },
				Outbound:     func() macro.Returns { return new(MeshCommercializeIssuedReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.issued"},
				},
			},
			"Dump": {
				DeclaredKind: (*prsim.Commercialize)(nil),
				TName:        "prsim.Commercialize",
				Name:         "Dump",
				Intype:       func() macro.Parameters { var parameters MeshCommercializeDumpParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCommercializeDumpReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCommercializeDumpParameters) },
				Outbound:     func() macro.Returns { return new(MeshCommercializeDumpReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.dump"},
				},
			},
		},
	})
}

// meshCommercializeMPI is an implementation of Commercialize
type meshCommercializeMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshCommercializeMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshCommercializeMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshCommercializeMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Sign license, only glab has permission to sign.
// @MPI("mesh.license.sign")
func (that *meshCommercializeMPI) Sign(ctx context.Context, lsr *types.License) (*types.CommerceLicense, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Sign"], lsr)
	if nil != err {
		x := new(MeshCommercializeSignReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCommercializeSignReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCommercializeSignReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// History list the sign license in history, the latest is the first index.
// @MPI("mesh.license.history")
func (that *meshCommercializeMPI) History(ctx context.Context, instId string) ([]*types.CommerceLicense, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["History"], instId)
	if nil != err {
		x := new(MeshCommercializeHistoryReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCommercializeHistoryReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCommercializeHistoryReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Issued mesh node identity.
// @MPI("mesh.net.issued")
func (that *meshCommercializeMPI) Issued(ctx context.Context, name string, kind string, cname string) (*types.CommerceEnviron, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Issued"], name, kind, cname)
	if nil != err {
		x := new(MeshCommercializeIssuedReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCommercializeIssuedReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCommercializeIssuedReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Dump the node identity.
// @MPI("mesh.net.dump")
func (that *meshCommercializeMPI) Dump(ctx context.Context, nodeId string) ([]*types.CommerceEnviron, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Dump"], nodeId)
	if nil != err {
		x := new(MeshCommercializeDumpReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCommercializeDumpReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCommercializeDumpReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

type MeshCommercializeSignParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Lsr         *types.License    `index:"0" json:"lsr" xml:"lsr" yaml:"lsr"`
}

func (that *MeshCommercializeSignParameters) GetKind() interface{} {
	return new(MeshCommercializeSignParameters)
}

func (that *MeshCommercializeSignParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Lsr)
	return arguments
}

func (that *MeshCommercializeSignParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Lsr = arguments[0].(*types.License)
		}
	}
}

func (that *MeshCommercializeSignParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCommercializeSignParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCommercializeSignReturns struct {
	Code    string                 `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string                 `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause           `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.CommerceLicense `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCommercializeSignReturns) GetCode() string {
	return that.Code
}

func (that *MeshCommercializeSignReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCommercializeSignReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCommercializeSignReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCommercializeSignReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCommercializeSignReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCommercializeSignReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCommercializeSignReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.CommerceLicense)
		}
	}
}

type MeshCommercializeHistoryParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	InstId      string            `index:"0" json:"inst_id" xml:"inst_id" yaml:"inst_id"`
}

func (that *MeshCommercializeHistoryParameters) GetKind() interface{} {
	return new(MeshCommercializeHistoryParameters)
}

func (that *MeshCommercializeHistoryParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.InstId)
	return arguments
}

func (that *MeshCommercializeHistoryParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.InstId = arguments[0].(string)
		}
	}
}

func (that *MeshCommercializeHistoryParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCommercializeHistoryParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCommercializeHistoryReturns struct {
	Code    string                   `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string                   `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause             `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []*types.CommerceLicense `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCommercializeHistoryReturns) GetCode() string {
	return that.Code
}

func (that *MeshCommercializeHistoryReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCommercializeHistoryReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCommercializeHistoryReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCommercializeHistoryReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCommercializeHistoryReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCommercializeHistoryReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCommercializeHistoryReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]*types.CommerceLicense)
		}
	}
}

type MeshCommercializeIssuedParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Name        string            `index:"0" json:"name" xml:"name" yaml:"name"`
	Kind        string            `index:"1" json:"kind" xml:"kind" yaml:"kind"`
	Cname       string            `index:"2" json:"cname" xml:"cname" yaml:"cname"`
}

func (that *MeshCommercializeIssuedParameters) GetKind() interface{} {
	return new(MeshCommercializeIssuedParameters)
}

func (that *MeshCommercializeIssuedParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Name)
	arguments = append(arguments, that.Kind)
	arguments = append(arguments, that.Cname)
	return arguments
}

func (that *MeshCommercializeIssuedParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Name = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Kind = arguments[1].(string)
		}
		if len(arguments) > 2 && nil != arguments[2] {
			that.Cname = arguments[2].(string)
		}
	}
}

func (that *MeshCommercializeIssuedParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCommercializeIssuedParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCommercializeIssuedReturns struct {
	Code    string                 `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string                 `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause           `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.CommerceEnviron `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCommercializeIssuedReturns) GetCode() string {
	return that.Code
}

func (that *MeshCommercializeIssuedReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCommercializeIssuedReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCommercializeIssuedReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCommercializeIssuedReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCommercializeIssuedReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCommercializeIssuedReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCommercializeIssuedReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.CommerceEnviron)
		}
	}
}

type MeshCommercializeDumpParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	NodeId      string            `index:"0" json:"node_id" xml:"node_id" yaml:"node_id"`
}

func (that *MeshCommercializeDumpParameters) GetKind() interface{} {
	return new(MeshCommercializeDumpParameters)
}

func (that *MeshCommercializeDumpParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.NodeId)
	return arguments
}

func (that *MeshCommercializeDumpParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.NodeId = arguments[0].(string)
		}
	}
}

func (that *MeshCommercializeDumpParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCommercializeDumpParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCommercializeDumpReturns struct {
	Code    string                   `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string                   `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause             `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []*types.CommerceEnviron `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCommercializeDumpReturns) GetCode() string {
	return that.Code
}

func (that *MeshCommercializeDumpReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCommercializeDumpReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCommercializeDumpReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCommercializeDumpReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCommercializeDumpReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCommercializeDumpReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCommercializeDumpReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]*types.CommerceEnviron)
		}
	}
}
