/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"

	"github.com/opendatav/mesh/client/golang/cause"
	"github.com/opendatav/mesh/client/golang/macro"
	"github.com/opendatav/mesh/client/golang/mpc"
	"github.com/opendatav/mesh/client/golang/prsim"
	"github.com/opendatav/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshDataHouseMPI)
	macro.Provide((*prsim.DataHouse)(nil), &meshDataHouseMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Writes": {
				DeclaredKind: (*prsim.DataHouse)(nil),
				TName:        "prsim.DataHouse",
				Name:         "Writes",
				Intype:       func() macro.Parameters { var parameters MeshDataHouseWritesParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshDataHouseWritesReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshDataHouseWritesParameters) },
				Outbound:     func() macro.Returns { return new(MeshDataHouseWritesReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.dh.writes"},
				},
			},
			"Write": {
				DeclaredKind: (*prsim.DataHouse)(nil),
				TName:        "prsim.DataHouse",
				Name:         "Write",
				Intype:       func() macro.Parameters { var parameters MeshDataHouseWriteParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshDataHouseWriteReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshDataHouseWriteParameters) },
				Outbound:     func() macro.Returns { return new(MeshDataHouseWriteReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.dh.write"},
				},
			},
			"Read": {
				DeclaredKind: (*prsim.DataHouse)(nil),
				TName:        "prsim.DataHouse",
				Name:         "Read",
				Intype:       func() macro.Parameters { var parameters MeshDataHouseReadParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshDataHouseReadReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshDataHouseReadParameters) },
				Outbound:     func() macro.Returns { return new(MeshDataHouseReadReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.dh.read"},
				},
			},
			"Indies": {
				DeclaredKind: (*prsim.DataHouse)(nil),
				TName:        "prsim.DataHouse",
				Name:         "Indies",
				Intype:       func() macro.Parameters { var parameters MeshDataHouseIndiesParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshDataHouseIndiesReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshDataHouseIndiesParameters) },
				Outbound:     func() macro.Returns { return new(MeshDataHouseIndiesReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.dh.indies"},
				},
			},
			"Tables": {
				DeclaredKind: (*prsim.DataHouse)(nil),
				TName:        "prsim.DataHouse",
				Name:         "Tables",
				Intype:       func() macro.Parameters { var parameters MeshDataHouseTablesParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshDataHouseTablesReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshDataHouseTablesParameters) },
				Outbound:     func() macro.Returns { return new(MeshDataHouseTablesReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.dh.tables"},
				},
			},
		},
	})
}

// meshDataHouseMPI is an implementation of DataHouse
type meshDataHouseMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshDataHouseMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshDataHouseMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshDataHouseMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Writes
// @MPI("mesh.dh.writes")
func (that *meshDataHouseMPI) Writes(ctx context.Context, docs []*types.Document) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Writes"], docs)
	return err
}

// Write
// @MPI("mesh.dh.write")
func (that *meshDataHouseMPI) Write(ctx context.Context, doc *types.Document) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Write"], doc)
	return err
}

// Read
// @MPI("mesh.dh.read")
func (that *meshDataHouseMPI) Read(ctx context.Context, index *types.Paging) (*types.Page[any], error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Read"], index)
	if nil != err {
		x := new(MeshDataHouseReadReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshDataHouseReadReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshDataHouseReadReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Indies
// @MPI("mesh.dh.indies")
func (that *meshDataHouseMPI) Indies(ctx context.Context, index *types.Paging) (*types.Page[any], error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Indies"], index)
	if nil != err {
		x := new(MeshDataHouseIndiesReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshDataHouseIndiesReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshDataHouseIndiesReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Tables
// @MPI("mesh.dh.tables")
func (that *meshDataHouseMPI) Tables(ctx context.Context, index *types.Paging) (*types.Page[any], error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Tables"], index)
	if nil != err {
		x := new(MeshDataHouseTablesReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshDataHouseTablesReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshDataHouseTablesReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

type MeshDataHouseWritesParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Docs        []*types.Document `index:"0" json:"docs" xml:"docs" yaml:"docs"`
}

func (that *MeshDataHouseWritesParameters) GetKind() interface{} {
	return new(MeshDataHouseWritesParameters)
}

func (that *MeshDataHouseWritesParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Docs)
	return arguments
}

func (that *MeshDataHouseWritesParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Docs = arguments[0].([]*types.Document)
		}
	}
}

func (that *MeshDataHouseWritesParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshDataHouseWritesParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshDataHouseWritesReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshDataHouseWritesReturns) GetCode() string {
	return that.Code
}

func (that *MeshDataHouseWritesReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshDataHouseWritesReturns) GetMessage() string {
	return that.Message
}

func (that *MeshDataHouseWritesReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshDataHouseWritesReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshDataHouseWritesReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshDataHouseWritesReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshDataHouseWritesReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshDataHouseWriteParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Doc         *types.Document   `index:"0" json:"doc" xml:"doc" yaml:"doc"`
}

func (that *MeshDataHouseWriteParameters) GetKind() interface{} {
	return new(MeshDataHouseWriteParameters)
}

func (that *MeshDataHouseWriteParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Doc)
	return arguments
}

func (that *MeshDataHouseWriteParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Doc = arguments[0].(*types.Document)
		}
	}
}

func (that *MeshDataHouseWriteParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshDataHouseWriteParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshDataHouseWriteReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshDataHouseWriteReturns) GetCode() string {
	return that.Code
}

func (that *MeshDataHouseWriteReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshDataHouseWriteReturns) GetMessage() string {
	return that.Message
}

func (that *MeshDataHouseWriteReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshDataHouseWriteReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshDataHouseWriteReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshDataHouseWriteReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshDataHouseWriteReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshDataHouseReadParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Index       *types.Paging     `index:"0" json:"index" xml:"index" yaml:"index"`
}

func (that *MeshDataHouseReadParameters) GetKind() interface{} {
	return new(MeshDataHouseReadParameters)
}

func (that *MeshDataHouseReadParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Index)
	return arguments
}

func (that *MeshDataHouseReadParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Index = arguments[0].(*types.Paging)
		}
	}
}

func (that *MeshDataHouseReadParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshDataHouseReadParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshDataHouseReadReturns struct {
	Code    string           `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string           `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause     `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Page[any] `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshDataHouseReadReturns) GetCode() string {
	return that.Code
}

func (that *MeshDataHouseReadReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshDataHouseReadReturns) GetMessage() string {
	return that.Message
}

func (that *MeshDataHouseReadReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshDataHouseReadReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshDataHouseReadReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshDataHouseReadReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshDataHouseReadReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Page[any])
		}
	}
}

type MeshDataHouseIndiesParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Index       *types.Paging     `index:"0" json:"index" xml:"index" yaml:"index"`
}

func (that *MeshDataHouseIndiesParameters) GetKind() interface{} {
	return new(MeshDataHouseIndiesParameters)
}

func (that *MeshDataHouseIndiesParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Index)
	return arguments
}

func (that *MeshDataHouseIndiesParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Index = arguments[0].(*types.Paging)
		}
	}
}

func (that *MeshDataHouseIndiesParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshDataHouseIndiesParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshDataHouseIndiesReturns struct {
	Code    string           `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string           `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause     `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Page[any] `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshDataHouseIndiesReturns) GetCode() string {
	return that.Code
}

func (that *MeshDataHouseIndiesReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshDataHouseIndiesReturns) GetMessage() string {
	return that.Message
}

func (that *MeshDataHouseIndiesReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshDataHouseIndiesReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshDataHouseIndiesReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshDataHouseIndiesReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshDataHouseIndiesReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Page[any])
		}
	}
}

type MeshDataHouseTablesParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Index       *types.Paging     `index:"0" json:"index" xml:"index" yaml:"index"`
}

func (that *MeshDataHouseTablesParameters) GetKind() interface{} {
	return new(MeshDataHouseTablesParameters)
}

func (that *MeshDataHouseTablesParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Index)
	return arguments
}

func (that *MeshDataHouseTablesParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Index = arguments[0].(*types.Paging)
		}
	}
}

func (that *MeshDataHouseTablesParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshDataHouseTablesParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshDataHouseTablesReturns struct {
	Code    string           `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string           `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause     `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Page[any] `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshDataHouseTablesReturns) GetCode() string {
	return that.Code
}

func (that *MeshDataHouseTablesReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshDataHouseTablesReturns) GetMessage() string {
	return that.Message
}

func (that *MeshDataHouseTablesReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshDataHouseTablesReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshDataHouseTablesReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshDataHouseTablesReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshDataHouseTablesReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Page[any])
		}
	}
}
