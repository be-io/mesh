/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"
	"time"

	"github.com/opendatav/mesh/client/golang/cause"
	"github.com/opendatav/mesh/client/golang/macro"
	"github.com/opendatav/mesh/client/golang/mpc"
	"github.com/opendatav/mesh/client/golang/prsim"
	"github.com/opendatav/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshSchedulerMPI)
	macro.Provide((*prsim.Scheduler)(nil), &meshSchedulerMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Timeout": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Timeout",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerTimeoutParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerTimeoutReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerTimeoutParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerTimeoutReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.timeout"},
				},
			},
			"Cron": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Cron",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerCronParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerCronReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerCronParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerCronReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.cron"},
				},
			},
			"Period": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Period",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerPeriodParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerPeriodReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerPeriodParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerPeriodReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.period"},
				},
			},
			"Dump": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Dump",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerDumpParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerDumpReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerDumpParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerDumpReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.dump"},
				},
			},
			"Cancel": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Cancel",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerCancelParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerCancelReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerCancelParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerCancelReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.cancel"},
				},
			},
			"Stop": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Stop",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerStopParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerStopReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerStopParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerStopReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.stop"},
				},
			},
			"Emit": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Emit",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerEmitParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerEmitReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerEmitParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerEmitReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.emit"},
				},
			},
			"Shutdown": {
				DeclaredKind: (*prsim.Scheduler)(nil),
				TName:        "prsim.Scheduler",
				Name:         "Shutdown",
				Intype:       func() macro.Parameters { var parameters MeshSchedulerShutdownParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSchedulerShutdownReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSchedulerShutdownParameters) },
				Outbound:     func() macro.Returns { return new(MeshSchedulerShutdownReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.schedule.shutdown"},
				},
			},
		},
	})
}

// meshSchedulerMPI is an implementation of Scheduler
type meshSchedulerMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshSchedulerMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshSchedulerMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshSchedulerMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Timeout
// Schedules the specified {@link Timeout} for one-time execution after the specified delay.
// @MPI("mesh.schedule.timeout")
func (that *meshSchedulerMPI) Timeout(ctx context.Context, timeout *types.Timeout, duration time.Duration) (string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Timeout"], timeout, duration)
	if nil != err {
		x := new(MeshSchedulerTimeoutReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSchedulerTimeoutReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSchedulerTimeoutReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Cron
// Schedules with the cron expression. "0 * * 1-3 * ? *"
// @MPI("mesh.schedule.cron")
func (that *meshSchedulerMPI) Cron(ctx context.Context, cron string, topic *types.Topic) (string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Cron"], cron, topic)
	if nil != err {
		x := new(MeshSchedulerCronReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSchedulerCronReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSchedulerCronReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Period
// schedule with fixed duration.
// @MPI("mesh.schedule.period")
func (that *meshSchedulerMPI) Period(ctx context.Context, duration time.Duration, topic *types.Topic) (string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Period"], duration, topic)
	if nil != err {
		x := new(MeshSchedulerPeriodReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSchedulerPeriodReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSchedulerPeriodReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Dump max is 1000 items
// Releases all resources acquired by this {@link Scheduler} and cancels all
// tasks which were scheduled but not executed yet.
// @MPI("mesh.schedule.dump")
func (that *meshSchedulerMPI) Dump(ctx context.Context) ([]string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Dump"])
	if nil != err {
		x := new(MeshSchedulerDumpReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSchedulerDumpReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSchedulerDumpReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Cancel
// Attempts to cancel the {@link com.be.mesh.client.struct.Timeout} associated with this handle.
// If the task has been executed or cancelled already, it will return with
// no side effect.
// @MPI("mesh.schedule.cancel")
func (that *meshSchedulerMPI) Cancel(ctx context.Context, taskId string) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Cancel"], taskId)
	if nil != err {
		x := new(MeshSchedulerCancelReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSchedulerCancelReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSchedulerCancelReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Stop
// Attempts to stop the {@link com.be.mesh.client.struct.Timeout} associated with this handle.
// If the task has been executed or cancelled already, it will return with
// no side effect.
// @MPI("mesh.schedule.stop")
func (that *meshSchedulerMPI) Stop(ctx context.Context, taskId string) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Stop"], taskId)
	if nil != err {
		x := new(MeshSchedulerStopReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSchedulerStopReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSchedulerStopReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Emit the scheduler topic
// @MPI("mesh.schedule.emit")
func (that *meshSchedulerMPI) Emit(ctx context.Context, topic *types.Topic) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Emit"], topic)
	return err
}

// Shutdown the scheduler
// @MPI("mesh.schedule.shutdown")
func (that *meshSchedulerMPI) Shutdown(ctx context.Context, duration time.Duration) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Shutdown"], duration)
	return err
}

type MeshSchedulerTimeoutParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Timeout     *types.Timeout    `index:"0" json:"timeout" xml:"timeout" yaml:"timeout"`
	Duration    time.Duration     `index:"1" json:"duration" xml:"duration" yaml:"duration"`
}

func (that *MeshSchedulerTimeoutParameters) GetKind() interface{} {
	return new(MeshSchedulerTimeoutParameters)
}

func (that *MeshSchedulerTimeoutParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Timeout)
	arguments = append(arguments, that.Duration)
	return arguments
}

func (that *MeshSchedulerTimeoutParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Timeout = arguments[0].(*types.Timeout)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Duration = arguments[1].(time.Duration)
		}
	}
}

func (that *MeshSchedulerTimeoutParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerTimeoutParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerTimeoutReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content string       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSchedulerTimeoutReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerTimeoutReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerTimeoutReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerTimeoutReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerTimeoutReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerTimeoutReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerTimeoutReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSchedulerTimeoutReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(string)
		}
	}
}

type MeshSchedulerCronParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Cron        string            `index:"0" json:"cron" xml:"cron" yaml:"cron"`
	Topic       *types.Topic      `index:"1" json:"topic" xml:"topic" yaml:"topic"`
}

func (that *MeshSchedulerCronParameters) GetKind() interface{} {
	return new(MeshSchedulerCronParameters)
}

func (that *MeshSchedulerCronParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Cron)
	arguments = append(arguments, that.Topic)
	return arguments
}

func (that *MeshSchedulerCronParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Cron = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Topic = arguments[1].(*types.Topic)
		}
	}
}

func (that *MeshSchedulerCronParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerCronParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerCronReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content string       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSchedulerCronReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerCronReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerCronReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerCronReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerCronReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerCronReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerCronReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSchedulerCronReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(string)
		}
	}
}

type MeshSchedulerPeriodParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Duration    time.Duration     `index:"0" json:"duration" xml:"duration" yaml:"duration"`
	Topic       *types.Topic      `index:"1" json:"topic" xml:"topic" yaml:"topic"`
}

func (that *MeshSchedulerPeriodParameters) GetKind() interface{} {
	return new(MeshSchedulerPeriodParameters)
}

func (that *MeshSchedulerPeriodParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Duration)
	arguments = append(arguments, that.Topic)
	return arguments
}

func (that *MeshSchedulerPeriodParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Duration = arguments[0].(time.Duration)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Topic = arguments[1].(*types.Topic)
		}
	}
}

func (that *MeshSchedulerPeriodParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerPeriodParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerPeriodReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content string       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSchedulerPeriodReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerPeriodReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerPeriodReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerPeriodReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerPeriodReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerPeriodReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerPeriodReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSchedulerPeriodReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(string)
		}
	}
}

type MeshSchedulerDumpParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
}

func (that *MeshSchedulerDumpParameters) GetKind() interface{} {
	return new(MeshSchedulerDumpParameters)
}

func (that *MeshSchedulerDumpParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshSchedulerDumpParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

func (that *MeshSchedulerDumpParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerDumpParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerDumpReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []string     `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSchedulerDumpReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerDumpReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerDumpReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerDumpReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerDumpReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerDumpReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerDumpReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSchedulerDumpReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]string)
		}
	}
}

type MeshSchedulerCancelParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	TaskId      string            `index:"0" json:"task_id" xml:"task_id" yaml:"task_id"`
}

func (that *MeshSchedulerCancelParameters) GetKind() interface{} {
	return new(MeshSchedulerCancelParameters)
}

func (that *MeshSchedulerCancelParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.TaskId)
	return arguments
}

func (that *MeshSchedulerCancelParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.TaskId = arguments[0].(string)
		}
	}
}

func (that *MeshSchedulerCancelParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerCancelParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerCancelReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSchedulerCancelReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerCancelReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerCancelReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerCancelReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerCancelReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerCancelReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerCancelReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSchedulerCancelReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}

type MeshSchedulerStopParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	TaskId      string            `index:"0" json:"task_id" xml:"task_id" yaml:"task_id"`
}

func (that *MeshSchedulerStopParameters) GetKind() interface{} {
	return new(MeshSchedulerStopParameters)
}

func (that *MeshSchedulerStopParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.TaskId)
	return arguments
}

func (that *MeshSchedulerStopParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.TaskId = arguments[0].(string)
		}
	}
}

func (that *MeshSchedulerStopParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerStopParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerStopReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSchedulerStopReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerStopReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerStopReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerStopReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerStopReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerStopReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerStopReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSchedulerStopReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}

type MeshSchedulerEmitParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Topic       *types.Topic      `index:"0" json:"topic" xml:"topic" yaml:"topic"`
}

func (that *MeshSchedulerEmitParameters) GetKind() interface{} {
	return new(MeshSchedulerEmitParameters)
}

func (that *MeshSchedulerEmitParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Topic)
	return arguments
}

func (that *MeshSchedulerEmitParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Topic = arguments[0].(*types.Topic)
		}
	}
}

func (that *MeshSchedulerEmitParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerEmitParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerEmitReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshSchedulerEmitReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerEmitReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerEmitReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerEmitReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerEmitReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerEmitReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerEmitReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshSchedulerEmitReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshSchedulerShutdownParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Duration    time.Duration     `index:"0" json:"duration" xml:"duration" yaml:"duration"`
}

func (that *MeshSchedulerShutdownParameters) GetKind() interface{} {
	return new(MeshSchedulerShutdownParameters)
}

func (that *MeshSchedulerShutdownParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Duration)
	return arguments
}

func (that *MeshSchedulerShutdownParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Duration = arguments[0].(time.Duration)
		}
	}
}

func (that *MeshSchedulerShutdownParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSchedulerShutdownParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSchedulerShutdownReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshSchedulerShutdownReturns) GetCode() string {
	return that.Code
}

func (that *MeshSchedulerShutdownReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSchedulerShutdownReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSchedulerShutdownReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSchedulerShutdownReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSchedulerShutdownReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSchedulerShutdownReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshSchedulerShutdownReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}
