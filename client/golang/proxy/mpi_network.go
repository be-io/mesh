/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"

	"github.com/be-io/mesh/client/golang/cause"
	"github.com/be-io/mesh/client/golang/macro"
	"github.com/be-io/mesh/client/golang/mpc"
	"github.com/be-io/mesh/client/golang/prsim"
	"github.com/be-io/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshNetworkMPI)
	macro.Provide((*prsim.Network)(nil), &meshNetworkMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"GetEnviron": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "GetEnviron",
				Intype:       func() macro.Parameters { var parameters MeshNetworkGetEnvironParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkGetEnvironReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkGetEnvironParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkGetEnvironReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.environ"},
				},
			},
			"Accessible": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Accessible",
				Intype:       func() macro.Parameters { var parameters MeshNetworkAccessibleParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkAccessibleReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkAccessibleParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkAccessibleReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.accessible"},
				},
			},
			"Refresh": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Refresh",
				Intype:       func() macro.Parameters { var parameters MeshNetworkRefreshParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkRefreshReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkRefreshParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkRefreshReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.refresh"},
				},
			},
			"GetRoute": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "GetRoute",
				Intype:       func() macro.Parameters { var parameters MeshNetworkGetRouteParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkGetRouteReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkGetRouteParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkGetRouteReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.edge"},
				},
			},
			"GetRoutes": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "GetRoutes",
				Intype:       func() macro.Parameters { var parameters MeshNetworkGetRoutesParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkGetRoutesReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkGetRoutesParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkGetRoutesReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.edges"},
				},
			},
			"GetDomains": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "GetDomains",
				Intype:       func() macro.Parameters { var parameters MeshNetworkGetDomainsParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkGetDomainsReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkGetDomainsParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkGetDomainsReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.domains"},
				},
			},
			"PutDomains": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "PutDomains",
				Intype:       func() macro.Parameters { var parameters MeshNetworkPutDomainsParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkPutDomainsReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkPutDomainsParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkPutDomainsReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.resolve"},
				},
			},
			"Weave": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Weave",
				Intype:       func() macro.Parameters { var parameters MeshNetworkWeaveParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkWeaveReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkWeaveParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkWeaveReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.weave"},
				},
			},
			"Ack": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Ack",
				Intype:       func() macro.Parameters { var parameters MeshNetworkAckParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkAckReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkAckParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkAckReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.ack"},
				},
			},
			"Disable": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Disable",
				Intype:       func() macro.Parameters { var parameters MeshNetworkDisableParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkDisableReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkDisableParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkDisableReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.disable"},
				},
			},
			"Enable": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Enable",
				Intype:       func() macro.Parameters { var parameters MeshNetworkEnableParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkEnableReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkEnableParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkEnableReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.enable"},
				},
			},
			"Index": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Index",
				Intype:       func() macro.Parameters { var parameters MeshNetworkIndexParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkIndexReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkIndexParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkIndexReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.index"},
				},
			},
			"Version": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Version",
				Intype:       func() macro.Parameters { var parameters MeshNetworkVersionParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkVersionReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkVersionParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkVersionReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.version"},
				},
			},
			"Instx": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Instx",
				Intype:       func() macro.Parameters { var parameters MeshNetworkInstxParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkInstxReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkInstxParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkInstxReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.instx"},
				},
			},
			"Instr": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Instr",
				Intype:       func() macro.Parameters { var parameters MeshNetworkInstrParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkInstrReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkInstrParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkInstrReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.instr"},
				},
			},
			"Ally": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Ally",
				Intype:       func() macro.Parameters { var parameters MeshNetworkAllyParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkAllyReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkAllyParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkAllyReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.ally"},
				},
			},
			"Disband": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Disband",
				Intype:       func() macro.Parameters { var parameters MeshNetworkDisbandParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkDisbandReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkDisbandParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkDisbandReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.disband"},
				},
			},
			"Assert": {
				DeclaredKind: (*prsim.Network)(nil),
				TName:        "prsim.Network",
				Name:         "Assert",
				Intype:       func() macro.Parameters { var parameters MeshNetworkAssertParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshNetworkAssertReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshNetworkAssertParameters) },
				Outbound:     func() macro.Returns { return new(MeshNetworkAssertReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.net.assert"},
				},
			},
		},
	})
}

// meshNetworkMPI is an implementation of Network
type meshNetworkMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshNetworkMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshNetworkMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshNetworkMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// GetEnviron Get the meth network environment fixed information.
// @MPI("mesh.net.environ")
func (that *meshNetworkMPI) GetEnviron(ctx context.Context) (*types.Environ, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["GetEnviron"])
	if nil != err {
		x := new(MeshNetworkGetEnvironReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkGetEnvironReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkGetEnvironReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Accessible Check the mesh network is accessible.
// @MPI("mesh.net.accessible")
func (that *meshNetworkMPI) Accessible(ctx context.Context, route *types.Route) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Accessible"], route)
	if nil != err {
		x := new(MeshNetworkAccessibleReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkAccessibleReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkAccessibleReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Refresh the routes to mesh network.
// @MPI("mesh.net.refresh")
func (that *meshNetworkMPI) Refresh(ctx context.Context, routes []*types.Route) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Refresh"], routes)
	return err
}

// GetRoute the network edge route.
// @MPI("mesh.net.edge")
func (that *meshNetworkMPI) GetRoute(ctx context.Context, nodeId string) (*types.Route, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["GetRoute"], nodeId)
	if nil != err {
		x := new(MeshNetworkGetRouteReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkGetRouteReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkGetRouteReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// GetRoutes the network edge routes.
// @MPI("mesh.net.edges")
func (that *meshNetworkMPI) GetRoutes(ctx context.Context) ([]*types.Route, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["GetRoutes"])
	if nil != err {
		x := new(MeshNetworkGetRoutesReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkGetRoutesReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkGetRoutesReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// GetDomains the network domains.
// @MPI("mesh.net.domains")
func (that *meshNetworkMPI) GetDomains(ctx context.Context, kind string) ([]*types.Domain, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["GetDomains"], kind)
	if nil != err {
		x := new(MeshNetworkGetDomainsReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkGetDomainsReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkGetDomainsReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// PutDomains the network domains.
// @MPI("mesh.net.resolve")
func (that *meshNetworkMPI) PutDomains(ctx context.Context, kind string, domains []*types.Domain) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["PutDomains"], kind, domains)
	return err
}

// Weave the network.
// @MPI("mesh.net.weave")
func (that *meshNetworkMPI) Weave(ctx context.Context, route *types.Route) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Weave"], route)
	return err
}

// Ack the network.
// @MPI("mesh.net.ack")
func (that *meshNetworkMPI) Ack(ctx context.Context, route *types.Route) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Ack"], route)
	return err
}

// Disable the network
// @MPI("mesh.net.disable")
func (that *meshNetworkMPI) Disable(ctx context.Context, nodeId string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Disable"], nodeId)
	return err
}

// Enable the network
// @MPI("mesh.net.enable")
func (that *meshNetworkMPI) Enable(ctx context.Context, nodeId string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Enable"], nodeId)
	return err
}

// Index the network edges
// @MPI("mesh.net.index")
func (that *meshNetworkMPI) Index(ctx context.Context, index *types.Paging) (*types.Page[*types.Route], error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Index"], index)
	if nil != err {
		x := new(MeshNetworkIndexReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkIndexReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkIndexReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Version
// Network environment version.
// @MPI("mesh.net.version")
func (that *meshNetworkMPI) Version(ctx context.Context, nodeId string) (*types.Versions, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Version"], nodeId)
	if nil != err {
		x := new(MeshNetworkVersionReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkVersionReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkVersionReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Instx
// Network institutions.
// @MPI("mesh.net.instx")
func (that *meshNetworkMPI) Instx(ctx context.Context, index *types.Paging) (*types.Page[*types.Institution], error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Instx"], index)
	if nil != err {
		x := new(MeshNetworkInstxReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkInstxReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkInstxReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Instr
// Network institutions.
// @MPI("mesh.net.instr")
func (that *meshNetworkMPI) Instr(ctx context.Context, institutions []*types.Institution) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Instr"], institutions)
	return err
}

// Ally
// Network form alliance.
// @MPI("mesh.net.ally")
func (that *meshNetworkMPI) Ally(ctx context.Context, nodeIds []string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Ally"], nodeIds)
	return err
}

// Disband
// Network quit alliance.
// @MPI("mesh.net.disband")
func (that *meshNetworkMPI) Disband(ctx context.Context, nodeIds []string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Disband"], nodeIds)
	return err
}

// Assert
// Network feature assert.
// @MPI("mesh.net.assert")
func (that *meshNetworkMPI) Assert(ctx context.Context, feature string, nodeIds []string) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Assert"], feature, nodeIds)
	if nil != err {
		x := new(MeshNetworkAssertReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshNetworkAssertReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshNetworkAssertReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

type MeshNetworkGetEnvironParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
}

func (that *MeshNetworkGetEnvironParameters) GetKind() interface{} {
	return new(MeshNetworkGetEnvironParameters)
}

func (that *MeshNetworkGetEnvironParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkGetEnvironParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

func (that *MeshNetworkGetEnvironParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkGetEnvironParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkGetEnvironReturns struct {
	Code    string         `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string         `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause   `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Environ `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkGetEnvironReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkGetEnvironReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkGetEnvironReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkGetEnvironReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkGetEnvironReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkGetEnvironReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkGetEnvironReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkGetEnvironReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Environ)
		}
	}
}

type MeshNetworkAccessibleParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Route       *types.Route      `index:"0" json:"route" xml:"route" yaml:"route"`
}

func (that *MeshNetworkAccessibleParameters) GetKind() interface{} {
	return new(MeshNetworkAccessibleParameters)
}

func (that *MeshNetworkAccessibleParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Route)
	return arguments
}

func (that *MeshNetworkAccessibleParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Route = arguments[0].(*types.Route)
		}
	}
}

func (that *MeshNetworkAccessibleParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkAccessibleParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkAccessibleReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkAccessibleReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkAccessibleReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkAccessibleReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkAccessibleReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkAccessibleReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkAccessibleReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkAccessibleReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkAccessibleReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}

type MeshNetworkRefreshParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Routes      []*types.Route    `index:"0" json:"routes" xml:"routes" yaml:"routes"`
}

func (that *MeshNetworkRefreshParameters) GetKind() interface{} {
	return new(MeshNetworkRefreshParameters)
}

func (that *MeshNetworkRefreshParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Routes)
	return arguments
}

func (that *MeshNetworkRefreshParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Routes = arguments[0].([]*types.Route)
		}
	}
}

func (that *MeshNetworkRefreshParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkRefreshParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkRefreshReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkRefreshReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkRefreshReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkRefreshReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkRefreshReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkRefreshReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkRefreshReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkRefreshReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkRefreshReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkGetRouteParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	NodeId      string            `index:"0" json:"node_id" xml:"node_id" yaml:"node_id"`
}

func (that *MeshNetworkGetRouteParameters) GetKind() interface{} {
	return new(MeshNetworkGetRouteParameters)
}

func (that *MeshNetworkGetRouteParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.NodeId)
	return arguments
}

func (that *MeshNetworkGetRouteParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.NodeId = arguments[0].(string)
		}
	}
}

func (that *MeshNetworkGetRouteParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkGetRouteParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkGetRouteReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Route `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkGetRouteReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkGetRouteReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkGetRouteReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkGetRouteReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkGetRouteReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkGetRouteReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkGetRouteReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkGetRouteReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Route)
		}
	}
}

type MeshNetworkGetRoutesParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
}

func (that *MeshNetworkGetRoutesParameters) GetKind() interface{} {
	return new(MeshNetworkGetRoutesParameters)
}

func (that *MeshNetworkGetRoutesParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkGetRoutesParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

func (that *MeshNetworkGetRoutesParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkGetRoutesParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkGetRoutesReturns struct {
	Code    string         `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string         `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause   `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []*types.Route `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkGetRoutesReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkGetRoutesReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkGetRoutesReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkGetRoutesReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkGetRoutesReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkGetRoutesReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkGetRoutesReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkGetRoutesReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]*types.Route)
		}
	}
}

type MeshNetworkGetDomainsParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Kind        string            `index:"0" json:"kind" xml:"kind" yaml:"kind"`
}

func (that *MeshNetworkGetDomainsParameters) GetKind() interface{} {
	return new(MeshNetworkGetDomainsParameters)
}

func (that *MeshNetworkGetDomainsParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Kind)
	return arguments
}

func (that *MeshNetworkGetDomainsParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Kind = arguments[0].(string)
		}
	}
}

func (that *MeshNetworkGetDomainsParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkGetDomainsParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkGetDomainsReturns struct {
	Code    string          `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string          `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause    `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []*types.Domain `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkGetDomainsReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkGetDomainsReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkGetDomainsReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkGetDomainsReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkGetDomainsReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkGetDomainsReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkGetDomainsReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkGetDomainsReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]*types.Domain)
		}
	}
}

type MeshNetworkPutDomainsParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Kind        string            `index:"0" json:"kind" xml:"kind" yaml:"kind"`
	Domains     []*types.Domain   `index:"1" json:"domains" xml:"domains" yaml:"domains"`
}

func (that *MeshNetworkPutDomainsParameters) GetKind() interface{} {
	return new(MeshNetworkPutDomainsParameters)
}

func (that *MeshNetworkPutDomainsParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Kind)
	arguments = append(arguments, that.Domains)
	return arguments
}

func (that *MeshNetworkPutDomainsParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Kind = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Domains = arguments[1].([]*types.Domain)
		}
	}
}

func (that *MeshNetworkPutDomainsParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkPutDomainsParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkPutDomainsReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkPutDomainsReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkPutDomainsReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkPutDomainsReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkPutDomainsReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkPutDomainsReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkPutDomainsReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkPutDomainsReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkPutDomainsReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkWeaveParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Route       *types.Route      `index:"0" json:"route" xml:"route" yaml:"route"`
}

func (that *MeshNetworkWeaveParameters) GetKind() interface{} {
	return new(MeshNetworkWeaveParameters)
}

func (that *MeshNetworkWeaveParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Route)
	return arguments
}

func (that *MeshNetworkWeaveParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Route = arguments[0].(*types.Route)
		}
	}
}

func (that *MeshNetworkWeaveParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkWeaveParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkWeaveReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkWeaveReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkWeaveReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkWeaveReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkWeaveReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkWeaveReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkWeaveReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkWeaveReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkWeaveReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkAckParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Route       *types.Route      `index:"0" json:"route" xml:"route" yaml:"route"`
}

func (that *MeshNetworkAckParameters) GetKind() interface{} {
	return new(MeshNetworkAckParameters)
}

func (that *MeshNetworkAckParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Route)
	return arguments
}

func (that *MeshNetworkAckParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Route = arguments[0].(*types.Route)
		}
	}
}

func (that *MeshNetworkAckParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkAckParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkAckReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkAckReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkAckReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkAckReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkAckReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkAckReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkAckReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkAckReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkAckReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkDisableParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	NodeId      string            `index:"0" json:"node_id" xml:"node_id" yaml:"node_id"`
}

func (that *MeshNetworkDisableParameters) GetKind() interface{} {
	return new(MeshNetworkDisableParameters)
}

func (that *MeshNetworkDisableParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.NodeId)
	return arguments
}

func (that *MeshNetworkDisableParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.NodeId = arguments[0].(string)
		}
	}
}

func (that *MeshNetworkDisableParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkDisableParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkDisableReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkDisableReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkDisableReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkDisableReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkDisableReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkDisableReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkDisableReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkDisableReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkDisableReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkEnableParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	NodeId      string            `index:"0" json:"node_id" xml:"node_id" yaml:"node_id"`
}

func (that *MeshNetworkEnableParameters) GetKind() interface{} {
	return new(MeshNetworkEnableParameters)
}

func (that *MeshNetworkEnableParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.NodeId)
	return arguments
}

func (that *MeshNetworkEnableParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.NodeId = arguments[0].(string)
		}
	}
}

func (that *MeshNetworkEnableParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkEnableParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkEnableReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkEnableReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkEnableReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkEnableReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkEnableReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkEnableReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkEnableReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkEnableReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkEnableReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkIndexParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Index       *types.Paging     `index:"0" json:"index" xml:"index" yaml:"index"`
}

func (that *MeshNetworkIndexParameters) GetKind() interface{} {
	return new(MeshNetworkIndexParameters)
}

func (that *MeshNetworkIndexParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Index)
	return arguments
}

func (that *MeshNetworkIndexParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Index = arguments[0].(*types.Paging)
		}
	}
}

func (that *MeshNetworkIndexParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkIndexParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkIndexReturns struct {
	Code    string                    `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string                    `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause              `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Page[*types.Route] `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkIndexReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkIndexReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkIndexReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkIndexReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkIndexReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkIndexReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkIndexReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkIndexReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Page[*types.Route])
		}
	}
}

type MeshNetworkVersionParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	NodeId      string            `index:"0" json:"node_id" xml:"node_id" yaml:"node_id"`
}

func (that *MeshNetworkVersionParameters) GetKind() interface{} {
	return new(MeshNetworkVersionParameters)
}

func (that *MeshNetworkVersionParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.NodeId)
	return arguments
}

func (that *MeshNetworkVersionParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.NodeId = arguments[0].(string)
		}
	}
}

func (that *MeshNetworkVersionParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkVersionParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkVersionReturns struct {
	Code    string          `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string          `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause    `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Versions `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkVersionReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkVersionReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkVersionReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkVersionReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkVersionReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkVersionReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkVersionReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkVersionReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Versions)
		}
	}
}

type MeshNetworkInstxParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Index       *types.Paging     `index:"0" json:"index" xml:"index" yaml:"index"`
}

func (that *MeshNetworkInstxParameters) GetKind() interface{} {
	return new(MeshNetworkInstxParameters)
}

func (that *MeshNetworkInstxParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Index)
	return arguments
}

func (that *MeshNetworkInstxParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Index = arguments[0].(*types.Paging)
		}
	}
}

func (that *MeshNetworkInstxParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkInstxParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkInstxReturns struct {
	Code    string                          `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string                          `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause                    `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.Page[*types.Institution] `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkInstxReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkInstxReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkInstxReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkInstxReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkInstxReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkInstxReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkInstxReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkInstxReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.Page[*types.Institution])
		}
	}
}

type MeshNetworkInstrParameters struct {
	Attachments  map[string]string    `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Institutions []*types.Institution `index:"0" json:"institutions" xml:"institutions" yaml:"institutions"`
}

func (that *MeshNetworkInstrParameters) GetKind() interface{} {
	return new(MeshNetworkInstrParameters)
}

func (that *MeshNetworkInstrParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Institutions)
	return arguments
}

func (that *MeshNetworkInstrParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Institutions = arguments[0].([]*types.Institution)
		}
	}
}

func (that *MeshNetworkInstrParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkInstrParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkInstrReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkInstrReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkInstrReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkInstrReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkInstrReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkInstrReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkInstrReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkInstrReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkInstrReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkAllyParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	NodeIds     []string          `index:"0" json:"node_ids" xml:"node_ids" yaml:"node_ids"`
}

func (that *MeshNetworkAllyParameters) GetKind() interface{} {
	return new(MeshNetworkAllyParameters)
}

func (that *MeshNetworkAllyParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.NodeIds)
	return arguments
}

func (that *MeshNetworkAllyParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.NodeIds = arguments[0].([]string)
		}
	}
}

func (that *MeshNetworkAllyParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkAllyParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkAllyReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkAllyReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkAllyReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkAllyReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkAllyReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkAllyReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkAllyReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkAllyReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkAllyReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkDisbandParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	NodeIds     []string          `index:"0" json:"node_ids" xml:"node_ids" yaml:"node_ids"`
}

func (that *MeshNetworkDisbandParameters) GetKind() interface{} {
	return new(MeshNetworkDisbandParameters)
}

func (that *MeshNetworkDisbandParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.NodeIds)
	return arguments
}

func (that *MeshNetworkDisbandParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.NodeIds = arguments[0].([]string)
		}
	}
}

func (that *MeshNetworkDisbandParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkDisbandParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkDisbandReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshNetworkDisbandReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkDisbandReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkDisbandReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkDisbandReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkDisbandReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkDisbandReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkDisbandReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshNetworkDisbandReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshNetworkAssertParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Feature     string            `index:"0" json:"feature" xml:"feature" yaml:"feature"`
	NodeIds     []string          `index:"1" json:"node_ids" xml:"node_ids" yaml:"node_ids"`
}

func (that *MeshNetworkAssertParameters) GetKind() interface{} {
	return new(MeshNetworkAssertParameters)
}

func (that *MeshNetworkAssertParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Feature)
	arguments = append(arguments, that.NodeIds)
	return arguments
}

func (that *MeshNetworkAssertParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Feature = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.NodeIds = arguments[1].([]string)
		}
	}
}

func (that *MeshNetworkAssertParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshNetworkAssertParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshNetworkAssertReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshNetworkAssertReturns) GetCode() string {
	return that.Code
}

func (that *MeshNetworkAssertReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshNetworkAssertReturns) GetMessage() string {
	return that.Message
}

func (that *MeshNetworkAssertReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshNetworkAssertReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshNetworkAssertReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshNetworkAssertReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshNetworkAssertReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}
