/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"

	"github.com/opendatav/mesh/client/golang/cause"
	"github.com/opendatav/mesh/client/golang/macro"
	"github.com/opendatav/mesh/client/golang/mpc"
	"github.com/opendatav/mesh/client/golang/prsim"
	"github.com/opendatav/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshSessionMPI)
	macro.Provide((*prsim.Session)(nil), &meshSessionMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Peek": {
				DeclaredKind: (*prsim.Session)(nil),
				TName:        "prsim.Session",
				Name:         "Peek",
				Intype:       func() macro.Parameters { var parameters MeshSessionPeekParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSessionPeekReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSessionPeekParameters) },
				Outbound:     func() macro.Returns { return new(MeshSessionPeekReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.chan.peek"},
				},
			},
			"Pop": {
				DeclaredKind: (*prsim.Session)(nil),
				TName:        "prsim.Session",
				Name:         "Pop",
				Intype:       func() macro.Parameters { var parameters MeshSessionPopParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSessionPopReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSessionPopParameters) },
				Outbound:     func() macro.Returns { return new(MeshSessionPopReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.chan.pop"},
				},
			},
			"Push": {
				DeclaredKind: (*prsim.Session)(nil),
				TName:        "prsim.Session",
				Name:         "Push",
				Intype:       func() macro.Parameters { var parameters MeshSessionPushParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSessionPushReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSessionPushParameters) },
				Outbound:     func() macro.Returns { return new(MeshSessionPushReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.chan.push"},
				},
			},
			"Release": {
				DeclaredKind: (*prsim.Session)(nil),
				TName:        "prsim.Session",
				Name:         "Release",
				Intype:       func() macro.Parameters { var parameters MeshSessionReleaseParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshSessionReleaseReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshSessionReleaseParameters) },
				Outbound:     func() macro.Returns { return new(MeshSessionReleaseReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.chan.release"},
				},
			},
		},
	})
}

// meshSessionMPI is an implementation of Session
type meshSessionMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshSessionMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshSessionMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshSessionMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Peek
// Retrieves, but does not remove, the head of this queue,
// or returns None if this queue is empty.
// @MPI("mesh.chan.peek")
func (that *meshSessionMPI) Peek(ctx context.Context, topic string) ([]byte, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Peek"], topic)
	if nil != err {
		x := new(MeshSessionPeekReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSessionPeekReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSessionPeekReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Pop
// Retrieves and removes the head of this queue,
// or returns None if this queue is empty.
// @MPI("mesh.chan.pop")
func (that *meshSessionMPI) Pop(ctx context.Context, timeout types.Duration, topic string) ([]byte, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Pop"], timeout, topic)
	if nil != err {
		x := new(MeshSessionPopReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshSessionPopReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshSessionPopReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Push
// Inserts the specified element into this queue if it is possible to do
// so immediately without violating capacity restrictions.
// When using a capacity-restricted queue, this method is generally
// preferable to add, which can fail to insert an element only
// by throwing an exception.
// @MPI("mesh.chan.push")
func (that *meshSessionMPI) Push(ctx context.Context, payload []byte, metadata map[string]string, topic string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Push"], payload, metadata, topic)
	return err
}

// Release the channel session.
// @MPI("mesh.chan.release")
func (that *meshSessionMPI) Release(ctx context.Context, timeout types.Duration, topic string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Release"], timeout, topic)
	return err
}

type MeshSessionPeekParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Topic       string            `index:"0" json:"topic" xml:"topic" yaml:"topic"`
}

func (that *MeshSessionPeekParameters) GetKind() interface{} {
	return new(MeshSessionPeekParameters)
}

func (that *MeshSessionPeekParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Topic)
	return arguments
}

func (that *MeshSessionPeekParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Topic = arguments[0].(string)
		}
	}
}

func (that *MeshSessionPeekParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSessionPeekParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSessionPeekReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []byte       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSessionPeekReturns) GetCode() string {
	return that.Code
}

func (that *MeshSessionPeekReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSessionPeekReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSessionPeekReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSessionPeekReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSessionPeekReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSessionPeekReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSessionPeekReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]byte)
		}
	}
}

type MeshSessionPopParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Timeout     types.Duration    `index:"0" json:"timeout" xml:"timeout" yaml:"timeout"`
	Topic       string            `index:"1" json:"topic" xml:"topic" yaml:"topic"`
}

func (that *MeshSessionPopParameters) GetKind() interface{} {
	return new(MeshSessionPopParameters)
}

func (that *MeshSessionPopParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Timeout)
	arguments = append(arguments, that.Topic)
	return arguments
}

func (that *MeshSessionPopParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Timeout = arguments[0].(types.Duration)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Topic = arguments[1].(string)
		}
	}
}

func (that *MeshSessionPopParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSessionPopParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSessionPopReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []byte       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshSessionPopReturns) GetCode() string {
	return that.Code
}

func (that *MeshSessionPopReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSessionPopReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSessionPopReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSessionPopReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSessionPopReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSessionPopReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshSessionPopReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]byte)
		}
	}
}

type MeshSessionPushParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Payload     []byte            `index:"0" json:"payload" xml:"payload" yaml:"payload"`
	Metadata    map[string]string `index:"1" json:"metadata" xml:"metadata" yaml:"metadata"`
	Topic       string            `index:"2" json:"topic" xml:"topic" yaml:"topic"`
}

func (that *MeshSessionPushParameters) GetKind() interface{} {
	return new(MeshSessionPushParameters)
}

func (that *MeshSessionPushParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Payload)
	arguments = append(arguments, that.Metadata)
	arguments = append(arguments, that.Topic)
	return arguments
}

func (that *MeshSessionPushParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Payload = arguments[0].([]byte)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Metadata = arguments[1].(map[string]string)
		}
		if len(arguments) > 2 && nil != arguments[2] {
			that.Topic = arguments[2].(string)
		}
	}
}

func (that *MeshSessionPushParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSessionPushParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSessionPushReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshSessionPushReturns) GetCode() string {
	return that.Code
}

func (that *MeshSessionPushReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSessionPushReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSessionPushReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSessionPushReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSessionPushReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSessionPushReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshSessionPushReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshSessionReleaseParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Timeout     types.Duration    `index:"0" json:"timeout" xml:"timeout" yaml:"timeout"`
	Topic       string            `index:"1" json:"topic" xml:"topic" yaml:"topic"`
}

func (that *MeshSessionReleaseParameters) GetKind() interface{} {
	return new(MeshSessionReleaseParameters)
}

func (that *MeshSessionReleaseParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Timeout)
	arguments = append(arguments, that.Topic)
	return arguments
}

func (that *MeshSessionReleaseParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Timeout = arguments[0].(types.Duration)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Topic = arguments[1].(string)
		}
	}
}

func (that *MeshSessionReleaseParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshSessionReleaseParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshSessionReleaseReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshSessionReleaseReturns) GetCode() string {
	return that.Code
}

func (that *MeshSessionReleaseReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshSessionReleaseReturns) GetMessage() string {
	return that.Message
}

func (that *MeshSessionReleaseReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshSessionReleaseReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshSessionReleaseReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshSessionReleaseReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshSessionReleaseReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}
