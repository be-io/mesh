/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"
	"time"

	"github.com/opendatav/mesh/client/golang/cause"
	"github.com/opendatav/mesh/client/golang/macro"
	"github.com/opendatav/mesh/client/golang/mpc"
	"github.com/opendatav/mesh/client/golang/prsim"
	"github.com/opendatav/mesh/client/golang/types"
)

func init() {
	var _ macro.Interface = new(meshTokenizerMPI)
	macro.Provide((*prsim.Tokenizer)(nil), &meshTokenizerMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Apply": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Apply",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerApplyParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerApplyReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerApplyParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerApplyReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.trust.apply"},
				},
			},
			"Verify": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Verify",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerVerifyParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerVerifyReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerVerifyParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerVerifyReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.trust.verify"},
				},
			},
			"Quickauth": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Quickauth",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerQuickauthParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerQuickauthReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerQuickauthParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerQuickauthReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.oauth2.quickauth"},
				},
			},
			"Grant": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Grant",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerGrantParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerGrantReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerGrantParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerGrantReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.oauth2.grant"},
				},
			},
			"Accept": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Accept",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerAcceptParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerAcceptReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerAcceptParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerAcceptReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.oauth2.accept"},
				},
			},
			"Reject": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Reject",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerRejectParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerRejectReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerRejectParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerRejectReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.oauth2.reject"},
				},
			},
			"Authorize": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Authorize",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerAuthorizeParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerAuthorizeReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerAuthorizeParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerAuthorizeReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.oauth2.authorize"},
				},
			},
			"Authenticate": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Authenticate",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerAuthenticateParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerAuthenticateReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerAuthenticateParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerAuthenticateReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.oauth2.authenticate"},
				},
			},
			"Refresh": {
				DeclaredKind: (*prsim.Tokenizer)(nil),
				TName:        "prsim.Tokenizer",
				Name:         "Refresh",
				Intype:       func() macro.Parameters { var parameters MeshTokenizerRefreshParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshTokenizerRefreshReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshTokenizerRefreshParameters) },
				Outbound:     func() macro.Returns { return new(MeshTokenizerRefreshReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.oauth2.refresh"},
				},
			},
		},
	})
}

// meshTokenizerMPI is an implementation of Tokenizer
type meshTokenizerMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshTokenizerMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshTokenizerMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshTokenizerMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Apply
// @MPI("mesh.trust.apply")
func (that *meshTokenizerMPI) Apply(ctx context.Context, kind string, duration time.Duration) (string, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Apply"], kind, duration)
	if nil != err {
		x := new(MeshTokenizerApplyReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerApplyReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerApplyReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Verify
// @MPI("mesh.trust.verify")
func (that *meshTokenizerMPI) Verify(ctx context.Context, token string) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Verify"], token)
	if nil != err {
		x := new(MeshTokenizerVerifyReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerVerifyReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerVerifyReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Quickauth OAuth2 quick authorize, contains grant code and code authorize.
// @MPI("mesh.oauth2.quickauth")
func (that *meshTokenizerMPI) Quickauth(ctx context.Context, credential *types.Credential) (*types.AccessToken, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Quickauth"], credential)
	if nil != err {
		x := new(MeshTokenizerQuickauthReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerQuickauthReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerQuickauthReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Grant OAuth2 code grant.
// @MPI("mesh.oauth2.grant")
func (that *meshTokenizerMPI) Grant(ctx context.Context, credential *types.Credential) (*types.AccessGrant, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Grant"], credential)
	if nil != err {
		x := new(MeshTokenizerGrantReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerGrantReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerGrantReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Accept OAuth2 accept grant code.
// @MPI("mesh.oauth2.accept")
func (that *meshTokenizerMPI) Accept(ctx context.Context, code string) (*types.AccessCode, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Accept"], code)
	if nil != err {
		x := new(MeshTokenizerAcceptReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerAcceptReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerAcceptReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Reject OAuth2 reject grant code.
// @MPI("mesh.oauth2.reject")
func (that *meshTokenizerMPI) Reject(ctx context.Context, code string) error {
	_, err := that.invoker.Call(ctx, that.invoker, that.methods["Reject"], code)
	return err
}

// Authorize OAuth2 code authorize.
// @MPI("mesh.oauth2.authorize")
func (that *meshTokenizerMPI) Authorize(ctx context.Context, code string) (*types.AccessToken, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Authorize"], code)
	if nil != err {
		x := new(MeshTokenizerAuthorizeReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerAuthorizeReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerAuthorizeReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Authenticate OAuth2 authenticate.
// @MPI("mesh.oauth2.authenticate")
func (that *meshTokenizerMPI) Authenticate(ctx context.Context, token string) (*types.AccessID, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Authenticate"], token)
	if nil != err {
		x := new(MeshTokenizerAuthenticateReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerAuthenticateReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerAuthenticateReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Refresh OAuth2 auth token refresh.
// @MPI("mesh.oauth2.refresh")
func (that *meshTokenizerMPI) Refresh(ctx context.Context, token string) (*types.AccessToken, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Refresh"], token)
	if nil != err {
		x := new(MeshTokenizerRefreshReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshTokenizerRefreshReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshTokenizerRefreshReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

type MeshTokenizerApplyParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Kind        string            `index:"0" json:"kind" xml:"kind" yaml:"kind"`
	Duration    time.Duration     `index:"1" json:"duration" xml:"duration" yaml:"duration"`
}

func (that *MeshTokenizerApplyParameters) GetKind() interface{} {
	return new(MeshTokenizerApplyParameters)
}

func (that *MeshTokenizerApplyParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Kind)
	arguments = append(arguments, that.Duration)
	return arguments
}

func (that *MeshTokenizerApplyParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Kind = arguments[0].(string)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Duration = arguments[1].(time.Duration)
		}
	}
}

func (that *MeshTokenizerApplyParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerApplyParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerApplyReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content string       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerApplyReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerApplyReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerApplyReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerApplyReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerApplyReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerApplyReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerApplyReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerApplyReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(string)
		}
	}
}

type MeshTokenizerVerifyParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Token       string            `index:"0" json:"token" xml:"token" yaml:"token"`
}

func (that *MeshTokenizerVerifyParameters) GetKind() interface{} {
	return new(MeshTokenizerVerifyParameters)
}

func (that *MeshTokenizerVerifyParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Token)
	return arguments
}

func (that *MeshTokenizerVerifyParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Token = arguments[0].(string)
		}
	}
}

func (that *MeshTokenizerVerifyParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerVerifyParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerVerifyReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerVerifyReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerVerifyReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerVerifyReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerVerifyReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerVerifyReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerVerifyReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerVerifyReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerVerifyReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}

type MeshTokenizerQuickauthParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Credential  *types.Credential `index:"0" json:"credential" xml:"credential" yaml:"credential"`
}

func (that *MeshTokenizerQuickauthParameters) GetKind() interface{} {
	return new(MeshTokenizerQuickauthParameters)
}

func (that *MeshTokenizerQuickauthParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Credential)
	return arguments
}

func (that *MeshTokenizerQuickauthParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Credential = arguments[0].(*types.Credential)
		}
	}
}

func (that *MeshTokenizerQuickauthParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerQuickauthParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerQuickauthReturns struct {
	Code    string             `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string             `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause       `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.AccessToken `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerQuickauthReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerQuickauthReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerQuickauthReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerQuickauthReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerQuickauthReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerQuickauthReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerQuickauthReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerQuickauthReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.AccessToken)
		}
	}
}

type MeshTokenizerGrantParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Credential  *types.Credential `index:"0" json:"credential" xml:"credential" yaml:"credential"`
}

func (that *MeshTokenizerGrantParameters) GetKind() interface{} {
	return new(MeshTokenizerGrantParameters)
}

func (that *MeshTokenizerGrantParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Credential)
	return arguments
}

func (that *MeshTokenizerGrantParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Credential = arguments[0].(*types.Credential)
		}
	}
}

func (that *MeshTokenizerGrantParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerGrantParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerGrantReturns struct {
	Code    string             `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string             `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause       `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.AccessGrant `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerGrantReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerGrantReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerGrantReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerGrantReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerGrantReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerGrantReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerGrantReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerGrantReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.AccessGrant)
		}
	}
}

type MeshTokenizerAcceptParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Code        string            `index:"0" json:"code" xml:"code" yaml:"code"`
}

func (that *MeshTokenizerAcceptParameters) GetKind() interface{} {
	return new(MeshTokenizerAcceptParameters)
}

func (that *MeshTokenizerAcceptParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Code)
	return arguments
}

func (that *MeshTokenizerAcceptParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Code = arguments[0].(string)
		}
	}
}

func (that *MeshTokenizerAcceptParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerAcceptParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerAcceptReturns struct {
	Code    string            `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string            `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause      `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.AccessCode `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerAcceptReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerAcceptReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerAcceptReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerAcceptReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerAcceptReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerAcceptReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerAcceptReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerAcceptReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.AccessCode)
		}
	}
}

type MeshTokenizerRejectParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Code        string            `index:"0" json:"code" xml:"code" yaml:"code"`
}

func (that *MeshTokenizerRejectParameters) GetKind() interface{} {
	return new(MeshTokenizerRejectParameters)
}

func (that *MeshTokenizerRejectParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Code)
	return arguments
}

func (that *MeshTokenizerRejectParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Code = arguments[0].(string)
		}
	}
}

func (that *MeshTokenizerRejectParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerRejectParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerRejectReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
}

func (that *MeshTokenizerRejectReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerRejectReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerRejectReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerRejectReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerRejectReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerRejectReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerRejectReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	return arguments
}

func (that *MeshTokenizerRejectReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
	}
}

type MeshTokenizerAuthorizeParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Code        string            `index:"0" json:"code" xml:"code" yaml:"code"`
}

func (that *MeshTokenizerAuthorizeParameters) GetKind() interface{} {
	return new(MeshTokenizerAuthorizeParameters)
}

func (that *MeshTokenizerAuthorizeParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Code)
	return arguments
}

func (that *MeshTokenizerAuthorizeParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Code = arguments[0].(string)
		}
	}
}

func (that *MeshTokenizerAuthorizeParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerAuthorizeParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerAuthorizeReturns struct {
	Code    string             `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string             `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause       `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.AccessToken `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerAuthorizeReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerAuthorizeReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerAuthorizeReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerAuthorizeReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerAuthorizeReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerAuthorizeReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerAuthorizeReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerAuthorizeReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.AccessToken)
		}
	}
}

type MeshTokenizerAuthenticateParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Token       string            `index:"0" json:"token" xml:"token" yaml:"token"`
}

func (that *MeshTokenizerAuthenticateParameters) GetKind() interface{} {
	return new(MeshTokenizerAuthenticateParameters)
}

func (that *MeshTokenizerAuthenticateParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Token)
	return arguments
}

func (that *MeshTokenizerAuthenticateParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Token = arguments[0].(string)
		}
	}
}

func (that *MeshTokenizerAuthenticateParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerAuthenticateParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerAuthenticateReturns struct {
	Code    string          `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string          `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause    `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.AccessID `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerAuthenticateReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerAuthenticateReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerAuthenticateReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerAuthenticateReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerAuthenticateReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerAuthenticateReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerAuthenticateReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerAuthenticateReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.AccessID)
		}
	}
}

type MeshTokenizerRefreshParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Token       string            `index:"0" json:"token" xml:"token" yaml:"token"`
}

func (that *MeshTokenizerRefreshParameters) GetKind() interface{} {
	return new(MeshTokenizerRefreshParameters)
}

func (that *MeshTokenizerRefreshParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Token)
	return arguments
}

func (that *MeshTokenizerRefreshParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Token = arguments[0].(string)
		}
	}
}

func (that *MeshTokenizerRefreshParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshTokenizerRefreshParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshTokenizerRefreshReturns struct {
	Code    string             `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string             `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause       `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content *types.AccessToken `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshTokenizerRefreshReturns) GetCode() string {
	return that.Code
}

func (that *MeshTokenizerRefreshReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshTokenizerRefreshReturns) GetMessage() string {
	return that.Message
}

func (that *MeshTokenizerRefreshReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshTokenizerRefreshReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshTokenizerRefreshReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshTokenizerRefreshReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshTokenizerRefreshReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(*types.AccessToken)
		}
	}
}
