/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"

	"github.com/be-io/mesh/client/golang/cause"
	"github.com/be-io/mesh/client/golang/macro"
	"github.com/be-io/mesh/client/golang/mpc"
	"github.com/be-io/mesh/client/golang/prsim"
)

func init() {
	var _ macro.Interface = new(meshCryptorMPI)
	macro.Provide((*prsim.Cryptor)(nil), &meshCryptorMPI{
		invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
		methods: map[string]*macro.Method{
			"Encrypt": {
				DeclaredKind: (*prsim.Cryptor)(nil),
				TName:        "prsim.Cryptor",
				Name:         "Encrypt",
				Intype:       func() macro.Parameters { var parameters MeshCryptorEncryptParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCryptorEncryptReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCryptorEncryptParameters) },
				Outbound:     func() macro.Returns { return new(MeshCryptorEncryptReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.crypt.encrypt"},
				},
			},
			"Decrypt": {
				DeclaredKind: (*prsim.Cryptor)(nil),
				TName:        "prsim.Cryptor",
				Name:         "Decrypt",
				Intype:       func() macro.Parameters { var parameters MeshCryptorDecryptParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCryptorDecryptReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCryptorDecryptParameters) },
				Outbound:     func() macro.Returns { return new(MeshCryptorDecryptReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.crypt.decrypt"},
				},
			},
			"Hash": {
				DeclaredKind: (*prsim.Cryptor)(nil),
				TName:        "prsim.Cryptor",
				Name:         "Hash",
				Intype:       func() macro.Parameters { var parameters MeshCryptorHashParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCryptorHashReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCryptorHashParameters) },
				Outbound:     func() macro.Returns { return new(MeshCryptorHashReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.crypt.hash"},
				},
			},
			"Sign": {
				DeclaredKind: (*prsim.Cryptor)(nil),
				TName:        "prsim.Cryptor",
				Name:         "Sign",
				Intype:       func() macro.Parameters { var parameters MeshCryptorSignParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCryptorSignReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCryptorSignParameters) },
				Outbound:     func() macro.Returns { return new(MeshCryptorSignReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.crypt.sign"},
				},
			},
			"Verify": {
				DeclaredKind: (*prsim.Cryptor)(nil),
				TName:        "prsim.Cryptor",
				Name:         "Verify",
				Intype:       func() macro.Parameters { var parameters MeshCryptorVerifyParameters; return &parameters },
				Retype:       func() macro.Returns { var returns MeshCryptorVerifyReturns; return &returns },
				Inbound:      func() macro.Parameters { return new(MeshCryptorVerifyParameters) },
				Outbound:     func() macro.Returns { return new(MeshCryptorVerifyReturns) },
				MPI: &macro.MPIAnnotation{
					Meta: &macro.Rtt{Name: "mesh.crypt.verify"},
				},
			},
		},
	})
}

// meshCryptorMPI is an implementation of Cryptor
type meshCryptorMPI struct {
	invoker macro.Caller
	methods map[string]*macro.Method
}

func (that *meshCryptorMPI) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshMPI}
}

func (that *meshCryptorMPI) Rtt() *macro.Rtt {
	return &macro.Rtt{Name: macro.MeshMPI}
}

func (that *meshCryptorMPI) GetMethods() map[string]*macro.Method {
	return that.methods
}

// Encrypt binary to encrypted binary.
// @MPI("mesh.crypt.encrypt")
func (that *meshCryptorMPI) Encrypt(ctx context.Context, buff []byte, features map[string][]byte) ([]byte, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Encrypt"], buff, features)
	if nil != err {
		x := new(MeshCryptorEncryptReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCryptorEncryptReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCryptorEncryptReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Decrypt binary to decrypted binary.
// @MPI("mesh.crypt.decrypt")
func (that *meshCryptorMPI) Decrypt(ctx context.Context, buff []byte, features map[string][]byte) ([]byte, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Decrypt"], buff, features)
	if nil != err {
		x := new(MeshCryptorDecryptReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCryptorDecryptReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCryptorDecryptReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Hash compute the hash value.
// @MPI("mesh.crypt.hash")
func (that *meshCryptorMPI) Hash(ctx context.Context, buff []byte, features map[string][]byte) ([]byte, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Hash"], buff, features)
	if nil != err {
		x := new(MeshCryptorHashReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCryptorHashReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCryptorHashReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Sign compute the signature value.
// @MPI("mesh.crypt.sign")
func (that *meshCryptorMPI) Sign(ctx context.Context, buff []byte, features map[string][]byte) ([]byte, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Sign"], buff, features)
	if nil != err {
		x := new(MeshCryptorSignReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCryptorSignReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCryptorSignReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

// Verify the signature value.
// @MPI("mesh.crypt.verify")
func (that *meshCryptorMPI) Verify(ctx context.Context, buff []byte, features map[string][]byte) (bool, error) {
	ret, err := that.invoker.Call(ctx, that.invoker, that.methods["Verify"], buff, features)
	if nil != err {
		x := new(MeshCryptorVerifyReturns)
		return x.Content, err
	}
	x, ok := ret.(*MeshCryptorVerifyReturns)
	if ok {
		return x.Content, err
	}
	x = new(MeshCryptorVerifyReturns)
	return x.Content, cause.Errorf("Cant resolve response ")
}

type MeshCryptorEncryptParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Buff        []byte            `index:"0" json:"buff" xml:"buff" yaml:"buff"`
	Features    map[string][]byte `index:"1" json:"features" xml:"features" yaml:"features"`
}

func (that *MeshCryptorEncryptParameters) GetKind() interface{} {
	return new(MeshCryptorEncryptParameters)
}

func (that *MeshCryptorEncryptParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Buff)
	arguments = append(arguments, that.Features)
	return arguments
}

func (that *MeshCryptorEncryptParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Buff = arguments[0].([]byte)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Features = arguments[1].(map[string][]byte)
		}
	}
}

func (that *MeshCryptorEncryptParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCryptorEncryptParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCryptorEncryptReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []byte       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCryptorEncryptReturns) GetCode() string {
	return that.Code
}

func (that *MeshCryptorEncryptReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCryptorEncryptReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCryptorEncryptReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCryptorEncryptReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCryptorEncryptReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCryptorEncryptReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCryptorEncryptReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]byte)
		}
	}
}

type MeshCryptorDecryptParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Buff        []byte            `index:"0" json:"buff" xml:"buff" yaml:"buff"`
	Features    map[string][]byte `index:"1" json:"features" xml:"features" yaml:"features"`
}

func (that *MeshCryptorDecryptParameters) GetKind() interface{} {
	return new(MeshCryptorDecryptParameters)
}

func (that *MeshCryptorDecryptParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Buff)
	arguments = append(arguments, that.Features)
	return arguments
}

func (that *MeshCryptorDecryptParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Buff = arguments[0].([]byte)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Features = arguments[1].(map[string][]byte)
		}
	}
}

func (that *MeshCryptorDecryptParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCryptorDecryptParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCryptorDecryptReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []byte       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCryptorDecryptReturns) GetCode() string {
	return that.Code
}

func (that *MeshCryptorDecryptReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCryptorDecryptReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCryptorDecryptReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCryptorDecryptReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCryptorDecryptReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCryptorDecryptReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCryptorDecryptReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]byte)
		}
	}
}

type MeshCryptorHashParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Buff        []byte            `index:"0" json:"buff" xml:"buff" yaml:"buff"`
	Features    map[string][]byte `index:"1" json:"features" xml:"features" yaml:"features"`
}

func (that *MeshCryptorHashParameters) GetKind() interface{} {
	return new(MeshCryptorHashParameters)
}

func (that *MeshCryptorHashParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Buff)
	arguments = append(arguments, that.Features)
	return arguments
}

func (that *MeshCryptorHashParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Buff = arguments[0].([]byte)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Features = arguments[1].(map[string][]byte)
		}
	}
}

func (that *MeshCryptorHashParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCryptorHashParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCryptorHashReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []byte       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCryptorHashReturns) GetCode() string {
	return that.Code
}

func (that *MeshCryptorHashReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCryptorHashReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCryptorHashReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCryptorHashReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCryptorHashReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCryptorHashReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCryptorHashReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]byte)
		}
	}
}

type MeshCryptorSignParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Buff        []byte            `index:"0" json:"buff" xml:"buff" yaml:"buff"`
	Features    map[string][]byte `index:"1" json:"features" xml:"features" yaml:"features"`
}

func (that *MeshCryptorSignParameters) GetKind() interface{} {
	return new(MeshCryptorSignParameters)
}

func (that *MeshCryptorSignParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Buff)
	arguments = append(arguments, that.Features)
	return arguments
}

func (that *MeshCryptorSignParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Buff = arguments[0].([]byte)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Features = arguments[1].(map[string][]byte)
		}
	}
}

func (that *MeshCryptorSignParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCryptorSignParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCryptorSignReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content []byte       `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCryptorSignReturns) GetCode() string {
	return that.Code
}

func (that *MeshCryptorSignReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCryptorSignReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCryptorSignReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCryptorSignReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCryptorSignReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCryptorSignReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCryptorSignReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].([]byte)
		}
	}
}

type MeshCryptorVerifyParameters struct {
	Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
	Buff        []byte            `index:"0" json:"buff" xml:"buff" yaml:"buff"`
	Features    map[string][]byte `index:"1" json:"features" xml:"features" yaml:"features"`
}

func (that *MeshCryptorVerifyParameters) GetKind() interface{} {
	return new(MeshCryptorVerifyParameters)
}

func (that *MeshCryptorVerifyParameters) GetArguments(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Buff)
	arguments = append(arguments, that.Features)
	return arguments
}

func (that *MeshCryptorVerifyParameters) SetArguments(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Buff = arguments[0].([]byte)
		}
		if len(arguments) > 1 && nil != arguments[1] {
			that.Features = arguments[1].(map[string][]byte)
		}
	}
}

func (that *MeshCryptorVerifyParameters) GetAttachments(ctx context.Context) map[string]string {
	return that.Attachments
}

func (that *MeshCryptorVerifyParameters) SetAttachments(ctx context.Context, attachments map[string]string) {
	that.Attachments = attachments
}

type MeshCryptorVerifyReturns struct {
	Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
	Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
	Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
	Content bool         `index:"15" json:"content" xml:"content" yaml:"content"`
}

func (that *MeshCryptorVerifyReturns) GetCode() string {
	return that.Code
}

func (that *MeshCryptorVerifyReturns) SetCode(code string) {
	that.Code = code
}

func (that *MeshCryptorVerifyReturns) GetMessage() string {
	return that.Message
}

func (that *MeshCryptorVerifyReturns) SetMessage(message string) {
	that.Message = message
}

func (that *MeshCryptorVerifyReturns) GetCause(ctx context.Context) *macro.Cause {
	return that.Cause
}

func (that *MeshCryptorVerifyReturns) SetCause(ctx context.Context, cause *macro.Cause) {
	that.Cause = cause
}

func (that *MeshCryptorVerifyReturns) GetContent(ctx context.Context) []interface{} {
	var arguments []interface{}
	arguments = append(arguments, that.Content)
	return arguments
}

func (that *MeshCryptorVerifyReturns) SetContent(ctx context.Context, arguments ...interface{}) {
	if len(arguments) > 0 {
		if len(arguments) > 0 && nil != arguments[0] {
			that.Content = arguments[0].(bool)
		}
	}
}
