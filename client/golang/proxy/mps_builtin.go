/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
 */

// Code generated by mesh; DO NOT EDIT.

package proxy

import (
	"context"
	"strings"

	"github.com/be-io/mesh/client/golang/cause"
	"github.com/be-io/mesh/client/golang/macro"
	"github.com/be-io/mesh/client/golang/mpc"
	"github.com/be-io/mesh/client/golang/prsim"
	"github.com/be-io/mesh/client/golang/system"
	"github.com/be-io/mesh/client/golang/tool"
	"github.com/be-io/mesh/client/golang/types"
)

func init() {
	var service = &meshMeshBuiltinMPS{mps: new(system.MeshBuiltin)}
	var _ prsim.Builtin = service
	macro.Provide((*prsim.Builtin)(nil), service)

	var serviceDoc = &meshMeshBuiltinDocMPS{service: service}
	var _ mpc.Invoker = serviceDoc
	var _ macro.Caller = serviceDoc
	macro.Provide(mpc.IInvoker, serviceDoc)
	macro.Provide(macro.ICaller, serviceDoc)

	var serviceVersion = &meshMeshBuiltinVersionMPS{service: service}
	var _ mpc.Invoker = serviceVersion
	var _ macro.Caller = serviceVersion
	macro.Provide(mpc.IInvoker, serviceVersion)
	macro.Provide(macro.ICaller, serviceVersion)

	var serviceDebug = &meshMeshBuiltinDebugMPS{service: service}
	var _ mpc.Invoker = serviceDebug
	var _ macro.Caller = serviceDebug
	macro.Provide(mpc.IInvoker, serviceDebug)
	macro.Provide(macro.ICaller, serviceDebug)

	var serviceStats = &meshMeshBuiltinStatsMPS{service: service}
	var _ mpc.Invoker = serviceStats
	var _ macro.Caller = serviceStats
	macro.Provide(mpc.IInvoker, serviceStats)
	macro.Provide(macro.ICaller, serviceStats)

	var serviceFallback = &meshMeshBuiltinFallbackMPS{service: service}
	var _ mpc.Invoker = serviceFallback
	var _ macro.Caller = serviceFallback
	macro.Provide(mpc.IInvoker, serviceFallback)
	macro.Provide(macro.ICaller, serviceFallback)

}

// meshMeshBuiltinMPS is an implementation of system.MeshBuiltin
type meshMeshBuiltinMPS struct {
	mps *system.MeshBuiltin
}

func (that *meshMeshBuiltinMPS) Att() *macro.Att {
	return &macro.Att{Name: macro.MeshSPI}
}

func (that *meshMeshBuiltinMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: macro.MeshMPS}
}

// Doc export the documents.
// @MPI("${mesh.name}.builtin.doc")
func (that *meshMeshBuiltinMPS) Doc(ctx context.Context, name string, formatter string) (string, error) {
	return that.mps.Doc(ctx, name, formatter)
}

// Version will get the builtin application version.
// @MPI("${mesh.name}.builtin.version")
func (that *meshMeshBuiltinMPS) Version(ctx context.Context) (*types.Versions, error) {
	return that.mps.Version(ctx)
}

// Debug set the application log level.
// @MPI("${mesh.name}.builtin.debug")
func (that *meshMeshBuiltinMPS) Debug(ctx context.Context, features map[string]string) error {
	return that.mps.Debug(ctx, features)
}

// Stats will collect health check stats.
// @MPI("${mesh.name}.builtin.stats")
func (that *meshMeshBuiltinMPS) Stats(ctx context.Context, features []string) (map[string]string, error) {
	return that.mps.Stats(ctx, features)
}

// Fallback is fallback service
// @MPI("${mesh.name}.builtin.fallback")
func (that *meshMeshBuiltinMPS) Fallback(ctx context.Context) error {
	return that.mps.Fallback(ctx)
}

type meshMeshBuiltinDocMPS struct {
	service prsim.Builtin
}

func (that *meshMeshBuiltinDocMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("${mesh.name}.builtin.doc", "${mesh.name}", tool.Name.Get())}
}
func (that *meshMeshBuiltinDocMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("${mesh.name}.builtin.doc", "${mesh.name}", tool.Name.Get())}
}

func (that *meshMeshBuiltinDocMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(MeshBuiltinDocParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Doc(ctx, parameters.Name, parameters.Formatter)
}

func (that *meshMeshBuiltinDocMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*MeshBuiltinDocParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Doc(ctx, parameters.Name, parameters.Formatter)
}

type meshMeshBuiltinVersionMPS struct {
	service prsim.Builtin
}

func (that *meshMeshBuiltinVersionMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("${mesh.name}.builtin.version", "${mesh.name}", tool.Name.Get())}
}
func (that *meshMeshBuiltinVersionMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("${mesh.name}.builtin.version", "${mesh.name}", tool.Name.Get())}
}

func (that *meshMeshBuiltinVersionMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	return that.service.Version(ctx)
}

func (that *meshMeshBuiltinVersionMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	return that.service.Version(ctx)
}

type meshMeshBuiltinDebugMPS struct {
	service prsim.Builtin
}

func (that *meshMeshBuiltinDebugMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("${mesh.name}.builtin.debug", "${mesh.name}", tool.Name.Get())}
}
func (that *meshMeshBuiltinDebugMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("${mesh.name}.builtin.debug", "${mesh.name}", tool.Name.Get())}
}

func (that *meshMeshBuiltinDebugMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(MeshBuiltinDebugParameters)
	parameters.SetArguments(ctx, args...)
	return nil, that.service.Debug(ctx, parameters.Features)
}

func (that *meshMeshBuiltinDebugMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*MeshBuiltinDebugParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return nil, that.service.Debug(ctx, parameters.Features)
}

type meshMeshBuiltinStatsMPS struct {
	service prsim.Builtin
}

func (that *meshMeshBuiltinStatsMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("${mesh.name}.builtin.stats", "${mesh.name}", tool.Name.Get())}
}
func (that *meshMeshBuiltinStatsMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("${mesh.name}.builtin.stats", "${mesh.name}", tool.Name.Get())}
}

func (that *meshMeshBuiltinStatsMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	parameters := new(MeshBuiltinStatsParameters)
	parameters.SetArguments(ctx, args...)
	return that.service.Stats(ctx, parameters.Features)
}

func (that *meshMeshBuiltinStatsMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	parameters, ok := invocation.GetParameters().(*MeshBuiltinStatsParameters)
	if !ok {
		return nil, cause.CompatibleError("Service %s parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
	}
	return that.service.Stats(ctx, parameters.Features)
}

type meshMeshBuiltinFallbackMPS struct {
	service prsim.Builtin
}

func (that *meshMeshBuiltinFallbackMPS) Att() *macro.Att {
	return &macro.Att{Name: strings.ReplaceAll("${mesh.name}.builtin.fallback", "${mesh.name}", tool.Name.Get())}
}
func (that *meshMeshBuiltinFallbackMPS) Stt() *macro.Stt {
	return &macro.Stt{Name: strings.ReplaceAll("${mesh.name}.builtin.fallback", "${mesh.name}", tool.Name.Get())}
}

func (that *meshMeshBuiltinFallbackMPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
	return nil, that.service.Fallback(ctx)
}

func (that *meshMeshBuiltinFallbackMPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
	return nil, that.service.Fallback(ctx)
}
