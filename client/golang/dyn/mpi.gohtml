/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
*/

// Code generated by mesh; DO NOT EDIT.

package {{$.Attachments.pn}}

import (
{{with .Imports -}}
    {{range $Import := . -}}
        {{$Import}}
    {{end -}}
{{end -}}
)

func init() {
var _ macro.Interface = new(mesh{{.Type.Name.Name}}MPI)
macro.Provide((*{{$.Attachments.sn}})(nil), &mesh{{.Type.Name.Name}}MPI{
invoker: mpc.ServiceProxy.Reference(&macro.Rtt{}),
methods: map[string]*macro.Method{
{{with .Methods -}}
    {{range $Method := . -}}
        {{if Has .Annotations "MPI" -}}
            "{{.Name}}": {
            DeclaredKind:  (*{{$.Attachments.sn}})(nil),
            TName: "{{$.Attachments.sn}}",
            Name:  "{{.Name}}",
            Intype: func()macro.Parameters { var parameters Mesh{{$.Type.Name.Name}}{{.Name}}Parameters; return &parameters },
            Retype: func()macro.Returns { var returns Mesh{{$.Type.Name.Name}}{{.Name}}Returns; return &returns },
            Inbound: func() macro.Parameters { return new(Mesh{{$.Type.Name.Name}}{{.Name}}Parameters) },
            Outbound: func() macro.Returns { return new(Mesh{{$.Type.Name.Name}}{{.Name}}Returns) },
            MPI: &macro.MPIAnnotation{
            Meta: &macro.Rtt{ {{range $Key, $Value := .Annotations.MPI}}{{$Key}}: {{$Value}},{{end}} },
            },
            },
        {{end -}}
    {{end -}}
{{end -}}
},
})
}

// mesh{{.Type.Name.Name}}MPI is an implementation of {{.Type.Name.Name}}
type mesh{{.Type.Name.Name}}MPI struct {
invoker macro.Caller
methods map[string]*macro.Method
}

func (that *mesh{{.Type.Name.Name}}MPI) Att() *macro.Att {
return &macro.Att{Name: {{index .Annotations.MPI "Name"}}}
}

func (that *mesh{{.Type.Name.Name}}MPI) Rtt() *macro.Rtt {
return &macro.Rtt{ {{range $Key, $Value := .Annotations.MPI}}{{$Key}}: {{$Value}},{{end}} }
}

func (that *mesh{{.Type.Name.Name}}MPI) GetMethods() map[string]*macro.Method {
return that.methods
}

{{with .Methods -}}
    {{range $Method := .}}
        {{if Has .Annotations "MPI"}}
            {{if $Method.Comments}}{{$Method.Comments}}{{end}}
            func (that *mesh{{$.Type.Name.Name}}MPI) {{.Name}}({{range $Index, $Param := .Params}}{{if $Index}}, {{end}}{{$Param.Name}} {{$Param.Type}}{{end}}) ({{range $Index, $Param := .Res}}{{if $Index}}, {{end}}{{$Param.Name}} {{$Param.Type}}{{end}}) {
            {{if NoReturn .Res}}_{{else}}ret{{end}}, err := that.invoker.Call(ctx, that.invoker, that.methods["{{.Name}}"], {{range $Index, $Param := .Params}}{{if Neq $Param.Type "context.Context"}}{{if Eq $Index 1}}, {{end}}{{$Param.Name}}{{end}}{{end}})
            {{if NoReturn .Res -}}
                return err
            {{else -}}
                if nil != err {
                x := new(Mesh{{$.Type.Name.Name}}{{.Name}}Returns)
                return {{range $Index, $Param := .Res}}{{if Neq $Param.Type "error"}}{{if $Index}}, {{end}}x.{{if $Index}}Content{{$Index}}{{else}}Content{{end}}{{end}}{{end}}, err
                }
                x, ok := ret.(*Mesh{{$.Type.Name.Name}}{{.Name}}Returns)
                if ok {
                return {{range $Index, $Param := .Res}}{{if Neq $Param.Type "error"}}{{if $Index}}, {{end}}x.{{if $Index}}Content{{$Index}}{{else}}Content{{end}}{{end}}{{end}}, err
                }
                x = new(Mesh{{$.Type.Name.Name}}{{.Name}}Returns)
                return {{range $Index, $Param := .Res}}{{if Neq $Param.Type "error"}}{{if $Index}}, {{end}}x.{{if $Index}}Content{{$Index}}{{else}}Content{{end}}{{end}}{{end}}, cause.Errorf("Cant resolve response ")
            {{end -}}
            }
        {{end -}}
    {{end -}}
{{end -}}

{{with .Methods -}}
    {{range $Method := .}}
        {{if Has .Annotations "MPI" -}}
            type Mesh{{$.Type.Name.Name}}{{.Name}}Parameters struct {
            Attachments map[string]string `index:"-1" json:"attachments" xml:"attachments" yaml:"attachments"`
            {{range $Index, $Param := .Params -}}
                {{if Neq $Param.Type "context.Context" -}}
                    {{FistUpper $Param.Name}} {{$Param.Type}} {{$.Attachments.comma}}index:"{{Minus $Index 1}}" json:"{{LowerUnder $Param.Name}}" xml:"{{LowerUnder $Param.Name}}" yaml:"{{LowerUnder $Param.Name}}"{{$.Attachments.comma}}
                {{end -}}
            {{end -}}
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Parameters) GetKind() interface{} {
            return new(Mesh{{$.Type.Name.Name}}{{.Name}}Parameters)
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Parameters) GetArguments(ctx context.Context) []interface{} {
            var arguments []interface{}
            {{range $Index, $Param := .Params -}}
                {{if Neq $Param.Type "context.Context" -}}
                    arguments = append(arguments, that.{{FistUpper $Param.Name}})
                {{end -}}
            {{end -}}
            return arguments
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Parameters) SetArguments(ctx context.Context, arguments ...interface{}) {
            if len(arguments) > 0 {
            {{range $Index, $Param := .Params -}}
                {{if Neq $Param.Type "context.Context" -}}
                    if len(arguments) > {{Minus $Index 1}} && nil != arguments[{{Minus $Index 1}}] {
                    that.{{FistUpper $Param.Name}} = arguments[{{Minus $Index 1}}].({{$Param.Type}})
                    }
                {{end -}}
            {{end -}}
            }
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Parameters) GetAttachments(ctx context.Context) map[string]string {
            return that.Attachments
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Parameters) SetAttachments(ctx context.Context, attachments map[string]string) {
            that.Attachments = attachments
            }

            type Mesh{{$.Type.Name.Name}}{{.Name}}Returns struct {
            Code    string       `index:"0" json:"code" xml:"code" yaml:"code" comment:"Result code"`
            Message string       `index:"5" json:"message" xml:"message" yaml:"message" comment:"Result message"`
            Cause   *macro.Cause `index:"10" json:"cause" xml:"cause" yaml:"cause" comment:"Service cause stacktrace"`
            {{range $Index, $Param := .Res -}}
                {{if Neq $Param.Type "error" -}}
                    {{if $Index}}Content{{$Index}}{{else}}Content{{end}} {{$Param.Type}} {{$.Attachments.comma}}index:"{{Multiply $Index 5 15}}" json:"{{if $Index}}content{{$Index}}{{else}}content{{end}}" xml:"{{if $Index}}content{{$Index}}{{else}}content{{end}}" yaml:"{{if $Index}}content{{$Index}}{{else}}content{{end}}"{{$.Attachments.comma}}
                {{end -}}
            {{end -}}
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) GetCode() string {
            return that.Code
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) SetCode(code string) {
            that.Code = code
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) GetMessage() string {
            return that.Message
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) SetMessage(message string) {
            that.Message = message
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) GetCause(ctx context.Context) *macro.Cause {
            return that.Cause
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) SetCause(ctx context.Context, cause *macro.Cause) {
            that.Cause = cause
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) GetContent(ctx context.Context) []interface{} {
            var arguments []interface{}
            {{range $Index, $Param := .Res -}}
                {{if Neq $Param.Type "error" -}}
                    arguments = append(arguments, that.{{if $Index}}Content{{$Index}}{{else}}Content{{end}})
                {{end -}}
            {{end -}}
            return arguments
            }

            func (that *Mesh{{$.Type.Name.Name}}{{.Name}}Returns) SetContent(ctx context.Context, arguments ...interface{}) {
            if len(arguments) > 0 {
            {{range $Index, $Param := .Res -}}
                {{if Neq $Param.Type "error" -}}
                    if len(arguments) > {{$Index}} && nil != arguments[{{$Index}}] {
                    that.{{if $Index}}Content{{$Index}}{{else}}Content{{end}} = arguments[{{$Index}}].({{$Param.Type}})
                    }
                {{end -}}
            {{end -}}
            }
            }
        {{end -}}
    {{end}}
{{end -}}
