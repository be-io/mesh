/*
* Copyright (c) 2000, 2023, trustbe and/or its affiliates. All rights reserved.
* TRUSTBE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
*
*
*/

// Code generated by mesh; DO NOT EDIT.

package {{$.Attachments.pn}}

import (
{{ with .Imports -}}
    {{range $Import := . -}}
        {{$Import}}
    {{end -}}
{{end -}}
)

func init() {
var service = &mesh{{.Type.Name.Name}}MPS{mps: new({{$.Attachments.an}})}
var _ {{$.Attachments.in}} = service
macro.Provide((*{{$.Attachments.in}})(nil), service)
{{with .Methods }}
    {{range $Method := .}}
        {{if Has .Annotations "MPI"}}
            var service{{.Name}} = &mesh{{$.Type.Name.Name}}{{.Name}}MPS{service: service}
            var _ mpc.Invoker = service{{.Name}}
            var _ macro.Caller = service{{.Name}}
            macro.Provide(mpc.IInvoker, service{{.Name}})
            macro.Provide(macro.ICaller, service{{.Name}})
        {{end}}
    {{end}}
{{end}}
}

// mesh{{.Type.Name.Name}}MPS is an implementation of {{$.Package.Name}}.{{$.Type.Name.Name}}
type mesh{{.Type.Name.Name}}MPS struct {
mps *{{$.Attachments.an}}
}

{{if Has .Annotations "Binding"}}
    func (that *mesh{{.Type.Name.Name}}MPS) Att() *macro.Att {
    return &macro.Att{Name: {{String .Annotations "Binding"}} }
    }

    func (that *mesh{{.Type.Name.Name}}MPS) Btt() *macro.Btt {
    return &macro.Btt{ {{range $Key, $Value := .Annotations.Binding}}{{$Key}}: {{$Value}},{{end}} }
    }
{{else}}
    func (that *mesh{{.Type.Name.Name}}MPS) Att() *macro.Att {
    return &macro.Att{Name: {{.Attachments.Name}} }
    }

    func (that *mesh{{.Type.Name.Name}}MPS) Stt() *macro.Stt {
    return &macro.Stt{ {{range $Key, $Value := .Annotations.MPS}}{{$Key}}: {{$Value}},{{end}} }
    }
{{end}}

{{if Has .Annotations "ServiceInspector"}}
    func (that *mesh{{.Type.Name.Name}}MPS) Inspect() []macro.MPI {
    return that.mps.Inspect()
    }
{{end}}

{{ with .Methods }}
    {{range $Method := .}}
        {{if Has .Annotations "MPI"}}
            {{if $Method.Comments}}{{$Method.Comments}}{{end}}
            func (that *mesh{{$.Type.Name.Name}}MPS) {{.Name}}({{range $Index, $Param := .Params}}{{if $Index}}, {{end}}{{$Param.Name}} {{$Param.Type}}{{end}}) ({{range $Index, $Param := .Res}}{{if $Index}}, {{end}}{{$Param.Name}} {{$Param.Type}}{{end}}) {
            return that.mps.{{.Name}}({{range $Index, $Param := .Params}}{{if $Index}}, {{end}}{{$Param.Name}}{{end}})
            }
        {{end}}
    {{end}}
{{end}}

{{ with .Methods }}
    {{range $Method := .}}
        {{if Has .Annotations "MPI"}}
            type mesh{{$.Type.Name.Name}}{{.Name}}MPS struct {
            service {{$.Attachments.in}}
            }

            {{if and (Has $.Annotations "Binding") (eq .Name "Subscribe")}}
                func (that *mesh{{$.Type.Name.Name}}{{.Name}}MPS) Att() *macro.Att {
                return &macro.Att{Name: strings.ReplaceAll({{String $.Annotations "Binding"}}, "${mesh.name}", tool.ReplaceName(tool.Name.Get())) }
                }
                func (that *mesh{{$.Type.Name.Name}}{{.Name}}MPS) Btt() *macro.Btt {
                return &macro.Btt{ {{range $Key, $Value := $.Annotations.Binding}}{{$Key}}: {{$Value}},{{end}} }
                }
            {{else}}
                func (that *mesh{{$.Type.Name.Name}}{{.Name}}MPS) Att() *macro.Att {
                return &macro.Att{ Name: {{index .Annotations.MPI "Name"}} }
                }
                func (that *mesh{{$.Type.Name.Name}}{{.Name}}MPS) Stt() *macro.Stt {
                return &macro.Stt{ {{range $Key, $Value := .Annotations.MPI}}{{$Key}}: {{$Value}},{{end}} }
                }
            {{end}}

            func (that *mesh{{$.Type.Name.Name}}{{.Name}}MPS) Call(ctx context.Context, proxy interface{}, method macro.Inspector, args ...interface{}) (interface{}, error) {
            {{if HasParameters . -}}
                parameters := new({{$.Attachments.MPX}}Mesh{{$.Super.Name.Name}}{{.Name}}Parameters)
                parameters.SetArguments(ctx, args...)
            {{end -}}
            {{if NoReturn .Res -}}
                return nil, that.service.{{.Name}}(ctx{{range $Index, $Param := .Params}}{{if Neq $Param.Type "context.Context"}}{{if $Index}}, {{end}}parameters.{{FistUpper $Param.Name}}{{end}}{{end}})
            {{else -}}
                return that.service.{{.Name}}(ctx{{range $Index, $Param := .Params}}{{if Neq $Param.Type "context.Context"}}{{if $Index}}, {{end}}parameters.{{FistUpper $Param.Name}}{{end}}{{end}})
            {{end -}}
            }

            func (that *mesh{{$.Type.Name.Name}}{{.Name}}MPS) Invoke(ctx context.Context, invocation mpc.Invocation) (interface{}, error) {
            {{if HasParameters . -}}
                parameters, ok := invocation.GetParameters().(*{{$.Attachments.MPX}}Mesh{{$.Super.Name.Name}}{{.Name}}Parameters)
                if !ok {
                return nil, cause.CompatibleError("Service {{$.Attachments.placeholder}} parameters can't compatible. ", mpc.ContextWith(ctx).GetUrn())
                }
            {{end -}}
            {{if NoReturn .Res -}}
                return nil, that.service.{{.Name}}(ctx{{range $Index, $Param := .Params}}{{if Neq $Param.Type "context.Context"}}{{if $Index}}, {{end}}parameters.{{FistUpper $Param.Name}}{{end}}{{end}})
            {{else -}}
                return that.service.{{.Name}}(ctx{{range $Index, $Param := .Params}}{{if Neq $Param.Type "context.Context"}}{{if $Index}}, {{end}}parameters.{{FistUpper $Param.Name}}{{end}}{{end}})
            {{end -}}
            }
        {{end}}
    {{end}}
{{end}}